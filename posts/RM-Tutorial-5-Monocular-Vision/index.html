<!DOCTYPE html><html lang="zh" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content="days ago"><meta name="hour-prompt" content="hours ago"><meta name="minute-prompt" content="minutes ago"><meta name="justnow-prompt" content="just now"><meta name="generator" content="Jekyll v4.2.1" /><meta property="og:title" content="RM 教程 5 —— 单目视觉" /><meta name="author" content="Harry-hhj" /><meta property="og:locale" content="zh" /><meta name="description" content="RM 教程 5 —— 单目视觉" /><meta property="og:description" content="RM 教程 5 —— 单目视觉" /><link rel="canonical" href="https://harry-hhj.github.io/posts/RM-Tutorial-5-Monocular-Vision/" /><meta property="og:url" content="https://harry-hhj.github.io/posts/RM-Tutorial-5-Monocular-Vision/" /><meta property="og:site_name" content="Harry’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-10-15T21:30:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="RM 教程 5 —— 单目视觉" /><meta name="twitter:site" content="@None" /><meta name="twitter:creator" content="@Harry-hhj" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"author":{"@type":"Person","name":"Harry-hhj"},"description":"RM 教程 5 —— 单目视觉","url":"https://harry-hhj.github.io/posts/RM-Tutorial-5-Monocular-Vision/","@type":"BlogPosting","headline":"RM 教程 5 —— 单目视觉","dateModified":"2021-11-04T19:01:43+08:00","datePublished":"2021-10-15T21:30:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://harry-hhj.github.io/posts/RM-Tutorial-5-Monocular-Vision/"},"@context":"https://schema.org"}</script><title>RM 教程 5 —— 单目视觉 | Harry's Blog</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Harry's Blog"><meta name="application-name" content="Harry's Blog"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script> var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?f40851b91841f1abe810a63f8d41c2e2"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })(); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end" lang="en"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/avatar/avatar.jpeg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Harry's Blog</a></div><div class="site-subtitle font-italic">Write blogs, share ideas, make friends and enjoy life.</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <a href="https://github.com/Harry-hhj" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['Harry_hhj','163.com'].join('@')" aria-label="email" class="order-4" > <i class="fas fa-envelope"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>RM 教程 5 —— 单目视觉</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>RM 教程 5 —— 单目视觉</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Harry-hhj </span> on <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Fri, Oct 15, 2021, 9:30 PM +0800" >Oct 15<i class="unloaded">2021-10-15T21:30:00+08:00</i> </span></div><div> <span> Updated <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Thu, Nov 4, 2021, 7:01 PM +0800" >Nov 4<i class="unloaded">2021-11-04T19:01:43+08:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="7689 words">42 min read</span></div></div><div class="post-content"> <img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 639 639'%3E%3C/svg%3E" data-proofer-ignore data-src="https://raw.githubusercontent.com/Harry-hhj/Harry-hhj.github.io/master/_posts/2021-10-15-RM-Tutorial-5-Monocular-Vision.assets/IMG_4633.JPG" class="preview-img" alt="Preview Image" width="639" height="639"><h1 id="rm-教程-5--单目视觉">RM 教程 5 —— 单目视觉</h1><blockquote><p>机械是肉体， 电控是大脑， 视觉是灵魂</p></blockquote><h2 id="一仿射变换与透视变换">一、仿射变换与透视变换</h2><h3 id="0-再谈其次坐标系">0. 再谈其次坐标系</h3><p>在上一讲中，我们提到了齐次坐标系。对于二维平面上的点 $(x, y)$ ， 我们常常将它写成为 $(x, y, 1)^T$ ，这是一个典型的齐次坐标。同样的，在三维空间中，我们有坐标 $(x, y, z, 1)^T$ ，这也是一个齐次坐标形式。</p><p>显然，对于齐次坐标和非齐次坐标，我们可以简单地通过删除最后一个坐标 $1$ 来实现他们之间的转换。但这样看来，齐次坐标的表述仍然非常奇怪，因为它多了一个莫名其妙的限制，就是最后一个坐标数值一定为 $1$ 。那么一个坐标三元组 $(x, y, 2)^T$ 是否也有自己的意义呢?</p><p>对此，我们规定对于任何<strong>非零值</strong> $k$ ， $(kx, ky, k)^T$ 表示二维坐标中的同一个点，也就是说，当两个三元组相差一个公共倍数时，他们是等价的，也被成为坐标三元组中的<strong>等价类</strong>。</p><p>现在问题有出现了，在上面的定义中，我们规定 $k \ne 0$ ，那么当 $k = 0$ 时， 坐标三元组 $(x, y, 0)^T$ 是否有它的意义?</p><p>由于 $(x/0, y/0)^T$ 得到的应该是一个在无穷远方的点，因此我们称它为<strong>无穷远点</strong>。在二维空间中， 无穷远点形成<strong>无穷远直线</strong>。在三维中，他们形成<strong>无穷远平面</strong>。</p><h3 id="1-线性变换">1. 线性变换</h3><p>在谈仿射变换之前，我们先要复习一下线性变换。</p><p>线性变换从几何直观有三个要点：</p><ul><li>变换前是直线的，变换后依然是直线<li>直线比例保持不变<li>变换前是原点的，变换后依然是原点</ul><p>线性变换是通过矩阵乘法来实现的。</p><h3 id="1-仿射变换">1. 仿射变换</h3><p>仿射变换是一种特殊的坐标变换，在仿射变换下，形状的两个<strong>平行性</strong>和<strong>体积比</strong>保持不变。</p><p>如果从<strong>无穷远直线</strong>的角度理解仿射变换，那么： 假设在空间 $s$ 下直线 $l$ 为无穷远直线，当经过仿射变换 $A$ 后得到直线 $l’$ ， $l’$ 仍然为仿射变换后的空间 $s’$ 中的无穷远直线。</p><p>仿射变换的公式为： \(\begin{bmatrix} x'\\ y'\\ 1\\ \end{bmatrix} = \begin{bmatrix} \mathbf A &amp; \mathbf t\\ \mathbf 0^T &amp; 1\\ \end{bmatrix} \begin{bmatrix} x\\ y\\ 1\\ \end{bmatrix}\) 如果上述的表达方式太过数学化，我们可以用直观的方式帮助你理解仿射变换：</p><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/Harry-hhj/Harry-hhj.github.io/master/_posts/2021-10-15-RM-Tutorial-5-Monocular-Vision.assets/image-20211022102413466.png" alt="image-20211022102413466" /></p><p>对于仿射变换的感性理解就是，将输入图像想象为一个大的矩形橡胶片，然后通过在角上的推或拉变形来制作不同样子的平行四边形。</p><p>简单来说，“仿射变换”就是：“线性变换”+“平移”。</p><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/Harry-hhj/Harry-hhj.github.io/master/_posts/2021-10-15-RM-Tutorial-5-Monocular-Vision.assets/v2-01d06795480b91a9bc1fa57ce5fd7009_720w.gif" alt="img" style="zoom:80%;" /></p><p>仿射变换的不变性：</p><ul><li>线共点、点共线的关系不变<li>平行关系<li>中点<li>在一条直线上的几段线段的比例关系</ul><p>仿射变换会改变：</p><ul><li>线段长度<li>夹角角度</ul><p>对于二维空间中的仿射变换，他有透视变换 $6$ 个自由度（参数）， 对于三维空间中的仿射变换，他有 $12$ 个自由度。</p><h4 id="补充知识">补充知识</h4><p>仿射变换可以通过一系列的原子变换的复合来实现，包括：平移（Translation）、缩放（Scale）、翻转（Flip）、旋转（Rotation）和剪切（Shear）。理解这些特殊的变换对你理解仿射变换有一些帮助。</p><p>我们介绍一下几种常见的特殊的仿射变换：</p><h4 id="平移变换-translation">平移变换 Translation</h4><p>平移变换是一种“刚体变换”，不会产生形变的理想物体。变换矩阵为： \(\begin{bmatrix} 1 &amp; 0 &amp; t_x\\ 0 &amp; 1 &amp; t_y\\ 0 &amp; 0 &amp; 1\\ \end{bmatrix}\)</p><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/Harry-hhj/Harry-hhj.github.io/master/_posts/2021-10-15-RM-Tutorial-5-Monocular-Vision.assets/120296-20160218190323831-1569543156.png" alt="image" style="zoom:50%;" /></p><h4 id="缩放变换-scale">缩放变换 Scale</h4><p>将每一点的横坐标放大（缩小）至 $s_x$ 倍，纵坐标放大（缩小）至 $s_y$ 倍。变换矩阵为： \(\begin{bmatrix} s_x &amp; 0 &amp; 0\\ 0 &amp; s_y &amp; 0\\ 0 &amp; 0 &amp; 1\\ \end{bmatrix}\)</p><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/Harry-hhj/Harry-hhj.github.io/master/_posts/2021-10-15-RM-Tutorial-5-Monocular-Vision.assets/120296-20160218190325738-1774950602.png" alt="image" style="zoom:100%;" /></p><h4 id="剪切变换-shear">剪切变换 Shear</h4><p>相当于一个横向剪切与一个纵向剪切的复合。变换矩阵为： \(\begin{bmatrix} 1 &amp; sh_x &amp; 0\\ sh_y &amp; 1 &amp; 0\\ 0 &amp; 0 &amp; 1\\ \end{bmatrix} = \begin{bmatrix} 1 &amp; 0 &amp; 0\\ sh_y &amp; 1 &amp; 0\\ 0 &amp; 0 &amp; 1\\ \end{bmatrix} \begin{bmatrix} 1 &amp; sh_x &amp; 0\\ 0 &amp; 1 &amp; 0\\ 0 &amp; 0 &amp; 1\\ \end{bmatrix}\)</p><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/Harry-hhj/Harry-hhj.github.io/master/_posts/2021-10-15-RM-Tutorial-5-Monocular-Vision.assets/120296-20160218190327878-536745153.png" alt="image" style="zoom:75%;" /></p><h4 id="旋转变换-rotation">旋转变换 Rotation</h4><p>目标图形围绕原点顺时针旋转 $\theta$ 弧度。变换矩阵为： \(\begin{bmatrix} \cos(\theta) &amp; -\sin(\theta) &amp; 0\\ \sin(\theta) &amp; \cos(\theta) &amp; 0\\ 0 &amp; 0 &amp; 1\\ \end{bmatrix}\)</p><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/Harry-hhj/Harry-hhj.github.io/master/_posts/2021-10-15-RM-Tutorial-5-Monocular-Vision.assets/120296-20160218190329691-845904295.png" alt="image" style="zoom:75%;" /></p><h4 id="组合">组合</h4><p>旋转变换，目标图形以 $(x, y)$ 为轴心顺时针旋转 $\theta$ 弧度，相当于两次平移变换与一次原点旋转变换的复合：先移动到中心节点，然后旋转，然后再移动回去。变换矩阵为： \(\begin{bmatrix} \cos(\theta) &amp; -\sin(\theta) &amp; y-x\cos(\theta)+y\sin(\theta)\\ \sin(\theta) &amp; \cos(\theta) &amp; y-x\sin(\theta)-y\cos(\theta)\\ 0 &amp; 0 &amp; 1\\ \end{bmatrix} = \begin{bmatrix} 1 &amp; 0 &amp; -x\\ 0 &amp; 1 &amp; -y\\ 0 &amp; 0 &amp; 1\\ \end{bmatrix} \begin{bmatrix} \cos(\theta) &amp; -\sin(\theta) &amp; 0\\ \sin(\theta) &amp; \cos(\theta) &amp; 0\\ 0 &amp; 0 &amp; 1\\ \end{bmatrix} \begin{bmatrix} 1 &amp; 0 &amp; x\\ 0 &amp; 1 &amp; y\\ 0 &amp; 0 &amp; 1\\ \end{bmatrix}\)</p><p>这个转换矩阵也可以下面这样描述。</p><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/Harry-hhj/Harry-hhj.github.io/master/_posts/2021-10-15-RM-Tutorial-5-Monocular-Vision.assets/120296-20160218190332347-2105606145.png" alt="image" style="zoom:75%;" /></p><p>一些常用转换矩阵如下：</p><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/Harry-hhj/Harry-hhj.github.io/master/_posts/2021-10-15-RM-Tutorial-5-Monocular-Vision.assets/120296-20160222070734244-1956482228.png" alt="image" /></p><h3 id="2-透视变换">2. 透视变换</h3><p>仿射变换可以理解为透视变换的特殊形式。透视变换也叫投影变换。我们在仿射变换中提到，通过仿射变换，原图像中的无穷远线不变。与之相反，通过透视变换，原来的无穷远线不再是无穷远线。也就是说，对于一点 $(x, y, 0)^T$ ，它经过透视变换之后的坐标最后一元不再为零。</p><p>透视变换不再保证平行性。</p><p>在二维空间中，空间变换的一般形式公式如下： \(\begin{bmatrix} x'\\ y'\\ k'\\ \end{bmatrix} = \begin{bmatrix} a_{11} &amp; a_{12} &amp; a_{13}\\ a_{21} &amp; a_{22} &amp; a_{23}\\ a_{31} &amp; a_{32} &amp; a_{33}\\ \end{bmatrix} \begin{bmatrix} x\\ y\\ k\\ \end{bmatrix}\) 如果想通过这样的一个变换使得变换结果中的 $k’ \ne 0$ ，那么就必须满足 $a_{31}x + a_{32}y \ne 0$ 。</p><p>于是，我们自然而然地得到了透视变换的一般形式： \(\begin{bmatrix} x'\\ y'\\ k'\\ \end{bmatrix} = \begin{bmatrix} \mathbf A &amp; \mathbf t\\ \mathbf a^T &amp; v\\ \end{bmatrix} \begin{bmatrix} x\\ y\\ k\\ \end{bmatrix}\) 如果想要感性地理解透视变换，那么你可以想想从不同角度看同一个物体的效果。例如下图就是一个透视变换的示意图：</p><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/Harry-hhj/Harry-hhj.github.io/master/_posts/2021-10-15-RM-Tutorial-5-Monocular-Vision.assets/image-20211022112317594.png" alt="image-20211022112317594" style="zoom:30%;" /></p><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/Harry-hhj/Harry-hhj.github.io/master/_posts/2021-10-15-RM-Tutorial-5-Monocular-Vision.assets/image-20211022112337439.png" alt="image-20211022112337439" style="zoom:40%;" /></p><p>通过透视变换，我们可以转换原图的视角。</p><p>例如下图中，我们就将车道从平视图转换为俯视图：</p><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/Harry-hhj/Harry-hhj.github.io/master/_posts/2021-10-15-RM-Tutorial-5-Monocular-Vision.assets/image-20211022112426716.png" alt="image-20211022112426716" style="zoom:50%;" /></p><p>下图中我们将车牌从侧视图转换为正视图：</p><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/Harry-hhj/Harry-hhj.github.io/master/_posts/2021-10-15-RM-Tutorial-5-Monocular-Vision.assets/image-20211022112502350.png" alt="image-20211022112502350" style="zoom:50%;" /></p><p>对于二维空间中的透视变换，它有 $8$ 个自由度，对于三维空间中的透视变换，它有 $15$ 个自由度。</p><h3 id="3-opencv中的仿射变换和透视变换">3. OpenCV中的仿射变换和透视变换</h3><p>在应用层面，仿射变换是图像基于 $3$ 个固定顶点的变换，如图所示：</p><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/Harry-hhj/Harry-hhj.github.io/master/_posts/2021-10-15-RM-Tutorial-5-Monocular-Vision.assets/v2-362633287ba80cd94a9f4efaf1ab31d8_1440w.png" alt="img" /></p><p>图中红点即为固定顶点，在变换先后固定顶点的像素值不变，图像整体则根据变换规则进行变换。</p><p>同理，透视变换是图像基于 $4$ 个固定顶点的变换，如图所示：</p><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/Harry-hhj/Harry-hhj.github.io/master/_posts/2021-10-15-RM-Tutorial-5-Monocular-Vision.assets/v2-1cb9c5539fa00b0a06aa0a2a367f4d42_1440w.png" alt="img" /></p><p>在OpenCV中，仿射变换和透视变换均有封装好的函数。</p><p>仿射变换的函数是：</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span text-data=" Cpp "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="n">cv</span><span class="o">::</span><span class="n">warpAffine</span><span class="p">(</span><span class="n">InputArray</span> <span class="n">src</span><span class="p">,</span> <span class="n">OutputArray</span> <span class="n">dst</span><span class="p">,</span> <span class="n">InputArray</span> <span class="n">M</span><span class="p">,</span> <span class="n">Size</span> <span class="n">dsize</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="o">=</span><span class="n">INTER_LINEAR</span><span class="p">,</span> <span class="kt">int</span> <span class="n">borderMode</span><span class="o">=</span><span class="n">BORDER_CONSTANT</span><span class="p">,</span> <span class="k">const</span> <span class="n">Scalar</span><span class="o">&amp;</span> <span class="n">borderValue</span><span class="o">=</span><span class="n">Scalar</span><span class="p">())</span>
</pre></table></code></div></div><p>参数：</p><ul><li><code class="language-plaintext highlighter-rouge">InputArray src</code>：输入变换前图像<li><code class="language-plaintext highlighter-rouge">OutputArray dst</code>：输出变换后图像，需要初始化一个空矩阵用来保存结果，不用设定矩阵尺寸<li><code class="language-plaintext highlighter-rouge">InputArray M</code>：变换矩阵，用另一个函数 <code class="language-plaintext highlighter-rouge">getAffineTransform()</code> 计算<li><code class="language-plaintext highlighter-rouge">Size dsize</code>：设置输出图像大小<li><code class="language-plaintext highlighter-rouge">int flags=INTER_LINEAR</code>：设置插值方式，默认方式为线性插值</ul><p>生成仿射变换矩阵函数是 <code class="language-plaintext highlighter-rouge">getAffineTransform()</code>：</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span text-data=" Cpp "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">cv</span><span class="o">::</span><span class="n">getAffineTransform</span><span class="p">(</span><span class="k">const</span> <span class="n">Point2f</span><span class="o">*</span> <span class="n">src</span><span class="p">,</span> <span class="k">const</span> <span class="n">Point2f</span><span class="o">*</span> <span class="n">dst</span><span class="p">)</span>
</pre></table></code></div></div><p>参数：</p><ul><li><p><code class="language-plaintext highlighter-rouge">const Point2f* src</code>：原图的 3 个固定顶点</p><li><p><code class="language-plaintext highlighter-rouge">const Point2f* dst</code>：目标图像的 3 个固定顶点</p><p>注意，顶点数组长度超过 3 个，则会自动以前 3 个为变换顶点；数组可用 <code class="language-plaintext highlighter-rouge">Point2f[]</code> 或 <code class="language-plaintext highlighter-rouge">Point2f*</code> 表示</p></ul><p>透视变换的函数是：</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span text-data=" Cpp "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="n">warpPerspective</span><span class="p">(</span><span class="n">InputArray</span> <span class="n">src</span><span class="p">,</span> <span class="n">OutputArray</span> <span class="n">dst</span><span class="p">,</span> <span class="n">InputArray</span> <span class="n">M</span><span class="p">,</span> <span class="n">Size</span> <span class="n">dsize</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="o">=</span><span class="n">INTER_LINEAR</span><span class="p">,</span> <span class="kt">int</span> <span class="n">borderMode</span><span class="o">=</span><span class="n">BORDER_CONSTANT</span><span class="p">,</span> <span class="k">const</span> <span class="n">Scalar</span><span class="o">&amp;</span> <span class="n">borderValue</span><span class="o">=</span><span class="n">Scalar</span><span class="p">())</span>
</pre></table></code></div></div><p>参数与 <code class="language-plaintext highlighter-rouge">warpAffine()</code> 一致。</p><p>生成透视变换矩阵函数是 <code class="language-plaintext highlighter-rouge">getPerspectiveTransform()</code>：</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span text-data=" Cpp "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">cv</span><span class="o">::</span><span class="n">getPerspectiveTransform</span><span class="p">(</span><span class="n">InputArray</span> <span class="n">src</span><span class="p">,</span> <span class="n">InputArray</span> <span class="n">dst</span><span class="p">,</span> <span class="kt">int</span> <span class="n">solveMethod</span> <span class="o">=</span> <span class="n">DECOMP_LU</span><span class="p">)</span>
</pre></table></code></div></div><p>参数：</p><ul><li>透视变换顶点为 4 个</ul><p>桌上有一张扑克牌，我们希望可以从正视的角度观察它。运行以下示例代码观察程序效果：</p><h2 id="二eigen">二、Eigen</h2><h3 id="1-简介">1. 简介</h3><p><code class="language-plaintext highlighter-rouge">Eigen</code> 是C++语言里的一个开源模版库，支持线性代数运算、矩阵和矢量运算、数值分析及其相关的算法。可以将它类比为 python 中的 <code class="language-plaintext highlighter-rouge">numpy</code> 。</p><p>注意如果想要发挥出 Eigen 的作用，编译时<strong>一定要打开 gcc/g++ 编译优化 <code class="language-plaintext highlighter-rouge">-O3</code></strong> 。</p><p><code class="language-plaintext highlighter-rouge">Eigen</code> 能算得快和它的设计思路有关，涵盖了算法加速的几个方法。</p><p>第一，<code class="language-plaintext highlighter-rouge">Eigen</code> 使用 Lazy Evaluation 的方法。这个方法的好处是：</p><ul><li><p>把所有能优化的步骤放在<strong>编译时</strong>去优化。让计算本身尽可能放在最后做，减少内存访问。例如下面一段代码：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span text-data=" C++ "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">Eigen</span><span class="o">::</span><span class="n">MatrixXd</span> <span class="n">Jacobian_i</span> <span class="o">=</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">MatrixXd</span><span class="o">::</span><span class="n">Random</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">MatrixXd</span> <span class="n">Jacobian_j</span> <span class="o">=</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">MatrixXd</span><span class="o">::</span><span class="n">Random</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">MatrixXd</span> <span class="n">Hessian</span> <span class="o">=</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">MatrixXd</span><span class="o">::</span><span class="n">Zero</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
<span class="n">Hessian</span> <span class="o">+=</span> <span class="n">Jacobian_i</span><span class="p">.</span><span class="n">transpose</span><span class="p">()</span> <span class="o">*</span> <span class="n">Jacobian_j</span><span class="p">;</span>
</pre></table></code></div></div><p>实际运行时，在 <code class="language-plaintext highlighter-rouge">operator+=()</code> 才真正去做内存读取和计算，而前面的步骤知识更新 flag 。具体见 <code class="language-plaintext highlighter-rouge">Eigen/src/Core/EigenBase.h</code> 。</p><li><p>不生成中间变量，减少内存搬运次数，而 <code class="language-plaintext highlighter-rouge">Eigen</code> 为了防止矩阵覆盖自己，对矩阵-矩阵乘法会生成一个中间变量。如果我们知道等式左右两边没有相同的项，则可以通知Eigen去取消中间变量。</p></ul><p>第二，改变内存的分配方式。使用Eigen时应该尽可能<strong>用静态内存代替动态内存</strong>。 <code class="language-plaintext highlighter-rouge">Eigen::MatrixXd</code> 是如下的缩写：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span text-data=" C++ "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="n">MatrixXd</span> <span class="n">Matrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="n">Dynamic</span><span class="p">,</span> <span class="n">Dynamic</span><span class="p">,</span> <span class="n">ColMajor</span><span class="o">&gt;</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">MatrixBase</code> 第二和第三个选项是行列的长度，有一项是 <code class="language-plaintext highlighter-rouge">Dynamic</code> 就会用动态内存分配。所以<strong>已知矩阵大小时应尽可能声明大小</strong>，比如 <code class="language-plaintext highlighter-rouge">Matrix&lt;double, 10, 10&gt;</code> 。如果内存在整个程序中大小会变，但知道<strong>最大可能的大小</strong>，都可以告知 <code class="language-plaintext highlighter-rouge">Eigen</code> ， <code class="language-plaintext highlighter-rouge">Eigen</code> 同样会选择用静态内存。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span text-data=" C++ "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Dynamic</span><span class="p">,</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Dynamic</span><span class="p">,</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">ColMajor</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="o">&gt;</span> <span class="n">Jacobian_i</span><span class="p">;</span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Dynamic</span><span class="p">,</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Dynamic</span><span class="p">,</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">ColMajor</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="o">&gt;</span> <span class="n">Jacobian_j</span><span class="p">;</span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Dynamic</span><span class="p">,</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Dynamic</span><span class="p">,</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">ColMajor</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="o">&gt;</span> <span class="n">Hessian</span> <span class="o">=</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="o">&gt;::</span><span class="n">Zero</span><span class="p">();</span>
<span class="n">Hessian</span> <span class="o">+=</span> <span class="n">Jacobian_i</span><span class="p">.</span><span class="n">transpose</span><span class="p">()</span> <span class="o">*</span> <span class="n">Jacobian_j</span><span class="p">;</span>
</pre></table></code></div></div><p>静态内存分配不但让我们节省了 <code class="language-plaintext highlighter-rouge">new/delete</code> 的开销，还给 <code class="language-plaintext highlighter-rouge">Eigen</code> 内部继续优化提供了可能。 <code class="language-plaintext highlighter-rouge">Eigen</code> 内置 Single-Instruction-Multiple-Data （SIMD）指令集，对稠密矩阵有很好的优化，如果能触发 CPU SIMD 的指令，能收获成倍的计算效率。</p><p>第三，矩阵自身的性质。如果矩阵本身有自身的性质，都可以通知 <code class="language-plaintext highlighter-rouge">Eigen</code> ，让 <code class="language-plaintext highlighter-rouge">Eigen</code> 用对应的加速方式。比如正定矩阵可以只用上三角进行计算，并且在求解时使用 <code class="language-plaintext highlighter-rouge">Eigen::LLT</code> 这样又快又数值稳定的解法等。</p><h3 id="2-安装-eigen">2. 安装 Eigen</h3><p>终端 <code class="language-plaintext highlighter-rouge">apt</code> 命令安装：</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span text-data=" Shell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nb">sudo </span>apt-get <span class="nb">install </span>libeigen3-dev
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">Eigen</code> 只包含头文件，因此它不需要实现编译（只需要使用 <code class="language-plaintext highlighter-rouge">#include</code> ），指定好 <code class="language-plaintext highlighter-rouge">Eigen</code> 的头文件路径，编译项目即可。<code class="language-plaintext highlighter-rouge">Eigen</code> 头文件的默认安装位置是 <code class="language-plaintext highlighter-rouge">/usr/include/eigen3</code> 。</p><h3 id="3-eigen-库的模块及其头文件">3. Eigen 库的模块及其头文件</h3><p>为了应对不同的需求， <code class="language-plaintext highlighter-rouge">Eigen</code> 库被分为多个功能模块，每个模块都有自己相对应的头文件，以供调用。 其中， <strong><code class="language-plaintext highlighter-rouge">Dense</code> 模块整合了绝大部分的模块</strong>，而 <code class="language-plaintext highlighter-rouge">Eigen</code> 模块更是整合了所有模块。</p><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/Harry-hhj/Harry-hhj.github.io/master/_posts/2021-10-15-RM-Tutorial-5-Monocular-Vision.assets/image-20211023213134661.png" alt="image-20211023213134661" /></p><h3 id="4-使用方法">4. 使用方法</h3><h4 id="1构造">（1）构造</h4><div class="language-c++ highlighter-rouge"><div class="code-header"> <span text-data=" C++ "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">A</span><span class="p">;</span>               <span class="c1">// Fixed rows and cols. Same as Matrix3d.</span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Dynamic</span><span class="o">&gt;</span> <span class="n">B</span><span class="p">;</span>         <span class="c1">// Fixed rows, dynamic cols.</span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Dynamic</span><span class="p">,</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Dynamic</span><span class="o">&gt;</span> <span class="n">C</span><span class="p">;</span>   <span class="c1">// Full dynamic. Same as MatrixXd.</span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">RowMajor</span><span class="o">&gt;</span> <span class="n">E</span><span class="p">;</span>     <span class="c1">// Row major; default is column-major.</span>
</pre></table></code></div></div><p>有一些宏定义可以简短代码：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span text-data=" C++ "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix2i</span>
<span class="k">typedef</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Dynamic</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">MatrixX3i</span>
<span class="k">typedef</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Dynamic</span><span class="o">&gt;</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix3Xi</span>
</pre></table></code></div></div><h4 id="2特殊矩阵生成">（2）特殊矩阵生成</h4><div class="table-wrapper"><table><thead><tr><th>实例<th>代码<tbody><tr><td>零矩阵<td><code class="language-plaintext highlighter-rouge">Eigen::Matrix&lt;int, 3, 3&gt;::Zero()</code><tr><td>一矩阵<td><code class="language-plaintext highlighter-rouge">Eigen::Matrix&lt;int, 3, 3&gt;::Ones()</code><tr><td>单位矩阵<td><code class="language-plaintext highlighter-rouge">Eigen::Matrix&lt;int, 3, 3&gt;::Identity()</code><tr><td>常量矩阵<td><code class="language-plaintext highlighter-rouge">Eigen::Matrix&lt;int, 3, 3&gt;::Constant(a)</code><tr><td>随机矩阵<td><code class="language-plaintext highlighter-rouge">Eigen::Matrix&lt;int, 3, 3&gt;::Random()</code><tr><td>线性空间向量<td><code class="language-plaintext highlighter-rouge">Eigen::Vector3i::LinSpaced(a, b)</code></table></div><h4 id="3随机访问">（3）随机访问</h4><p><code class="language-plaintext highlighter-rouge">Eigen</code> 有重载 <code class="language-plaintext highlighter-rouge">()</code> 运算符提供随机访问的功能。下面是一段例程：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span text-data=" C++ "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="n">Eigen</span><span class="o">::</span><span class="n">MatrixXd</span> <span class="nf">m</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
<span class="n">m</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="n">m</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="mf">2.5</span><span class="p">;</span>
<span class="n">m</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="n">m</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">m</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">m</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Here is the matrix m:</span><span class="se">\n</span><span class="s">"</span> <span class="o">&lt;&lt;</span> <span class="n">m</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

<span class="n">Eigen</span><span class="o">::</span><span class="n">VectorXd</span> <span class="nf">v</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="n">v</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="n">v</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">v</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Here is the vector v:</span><span class="se">\n</span><span class="s">"</span> <span class="o">&lt;&lt;</span> <span class="n">v</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</pre></table></code></div></div><h4 id="4赋值">（4）赋值</h4><p>利用重载 <code class="language-plaintext highlighter-rouge">&lt;&lt;</code> 运算符或 <code class="language-plaintext highlighter-rouge">=</code> 运算符完成赋值。下面是一段例程：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span text-data=" C++ "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix3f</span> <span class="n">m</span><span class="p">;</span>
<span class="n">m</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span>
     <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span>
     <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">m</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</pre></table></code></div></div><h4 id="5改变矩阵大小">（5）改变矩阵大小</h4><p>只能作用于<strong>大小没有通过模版确定</strong>的矩阵，即设置为 <code class="language-plaintext highlighter-rouge">Eigen::Dynamic</code> 的维度。</p><ul><li><code class="language-plaintext highlighter-rouge">resize(rows, cols)</code> ：可能改变矩阵数据的存储顺序。<li><code class="language-plaintext highlighter-rouge">conservativeResize(rows, cols)</code>：不会改变矩阵数据的内存分布，因此如果新生成的大小不能覆盖原来的数据，会造成数据丢失。可以减少赋值操作。</ul><p>下面是一段例程：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span text-data=" C++ "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Dynamic</span><span class="p">,</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Dynamic</span><span class="o">&gt;</span> <span class="n">m</span> <span class="o">=</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;::</span><span class="n">Identity</span><span class="p">();</span>
<span class="n">m</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">9</span><span class="p">);</span>
</pre></table></code></div></div><h4 id="6特殊">（6）特殊</h4><div class="table-wrapper"><table><thead><tr><th>函数<th>作用<th>返回<tbody><tr><td><code class="language-plaintext highlighter-rouge">transpose</code><td>转置<td><code class="language-plaintext highlighter-rouge">Matrix</code><tr><td><code class="language-plaintext highlighter-rouge">eval</code><td>返回矩阵的数值<td><code class="language-plaintext highlighter-rouge">Matrix</code><tr><td><code class="language-plaintext highlighter-rouge">transposeInPlace</code><td>自身进行转置<td><code class="language-plaintext highlighter-rouge">void</code><tr><td><code class="language-plaintext highlighter-rouge">inverse</code><td>取逆<td><code class="language-plaintext highlighter-rouge">Matrix</code></table></div><p>需要注意的是，由于 Eigen 使用 Lazy Evaluation，因此 <code class="language-plaintext highlighter-rouge">mat = mat.transpose()</code> 是不合法的。</p><h4 id="7单矩阵运算">（7）单矩阵运算</h4><div class="table-wrapper"><table><thead><tr><th>函数<th>作用<tbody><tr><td><code class="language-plaintext highlighter-rouge">mat.sum()</code><td>返回元素的和<tr><td><code class="language-plaintext highlighter-rouge">mat.prod()</code><td>返回元素的乘积和<tr><td><code class="language-plaintext highlighter-rouge">mat.maxCoeff()</code><td>返回最大元素<tr><td><code class="language-plaintext highlighter-rouge">mat.minCoeff()</code><td>返回最小元素<tr><td><code class="language-plaintext highlighter-rouge">mat.trace()</code><td>返回矩阵的迹</table></div><h4 id="8子阵运算">（8）子阵运算</h4><p>block 运算的功能是截取矩阵中的部分元素。</p><ul><li><code class="language-plaintext highlighter-rouge">mat.block(i,j,p,q)</code>：动态大小的 block 运算<li><code class="language-plaintext highlighter-rouge">mat.block&lt;p,q&gt;(i,j)</code>：确定大小的 block 运算</ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span text-data=" C++ "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="o">&gt;</span> <span class="n">matrix_1</span><span class="p">;</span>
<span class="n">matrix_1</span><span class="p">.</span><span class="n">block</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix2i</span><span class="o">::</span><span class="n">Ones</span><span class="p">();</span>
<span class="n">matrix_1</span><span class="p">.</span><span class="n">block</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector2i</span><span class="o">::</span><span class="n">Random</span><span class="p">();</span>
<span class="n">matrix_1</span><span class="p">.</span><span class="n">block</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">matrix_1</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</pre></table></code></div></div><div class="table-wrapper"><table><thead><tr><th>函数<th>作用<tbody><tr><td><code class="language-plaintext highlighter-rouge">mat.topLeftCorner(rows, cols)</code><td>取左上角的 block<tr><td><code class="language-plaintext highlighter-rouge">mat.topRightCorner(rows, cols)</code><td>取右上角的 block<tr><td><code class="language-plaintext highlighter-rouge">mat.bottomLeftCorner(rows, cols)</code><td>取左下角的 block<tr><td><code class="language-plaintext highlighter-rouge">mat.bottemRightCorner(rows, cols)</code><td>取右下角的 block<tr><td><code class="language-plaintext highlighter-rouge">mat.topRows(rows)</code><td>取上方 k 行<tr><td><code class="language-plaintext highlighter-rouge">mat.bottomRows(rows)</code><td>取下方 k 行<tr><td><code class="language-plaintext highlighter-rouge">mat.leftCols(cols)</code><td>取左侧 k 行<tr><td><code class="language-plaintext highlighter-rouge">mat.rightCols(cols)</code><td>取右方 k 行<tr><td><code class="language-plaintext highlighter-rouge">mat.cols(j)</code><td>取第 j 行<tr><td><code class="language-plaintext highlighter-rouge">mat.rows(i)</code><td>取第 i 行</table></div><h4 id="9广播">（9）广播</h4><p>将一个矩阵的一个大小为 $1$ 或缺失的维度重复补全后和另一个矩阵进行计算。例如，一个矩阵 A 维度为 $(3,3)$ ，另一个矩阵B维度为 $(3,1)$ 。那么运算 $A+B$ 中就发生了广播，矩阵 A 的维度被补全为 $(3,3)$ 后和 B 进行运算。下面是一段例程：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span text-data=" C++ "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="n">Eigen</span><span class="o">::</span><span class="n">MatrixXf</span> <span class="nf">mat</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">);</span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">VectorXf</span> <span class="nf">v</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="n">mat</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span>
       <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">2</span><span class="p">;</span>
<span class="n">v</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">mat</span><span class="p">.</span><span class="n">colwise</span><span class="p">()</span> <span class="o">+=</span> <span class="n">v</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">mat</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</pre></table></code></div></div><h2 id="三pnp">三、PnP</h2><p>PnP 常用于<strong>单目测距</strong>和<strong>姿态解算</strong>。</p><p>如果场景的三维结构已知，利用多个<strong>控制点在三维场景中的坐标及其在图像中的透视投影坐标</strong>即可求解出摄像机坐标系与表示三维场景结构的世界坐标系之间的绝对位姿关系，包括绝对<strong>平移向量 $t$ 以及旋转矩阵 $R$</strong> ，该类求解方法统称为 <strong>N 点透视位姿求解</strong>（ Perspective-N-Point ， PNP 问题）。这里的控制点是指<strong>准确知道三维空间坐标位置</strong>，同时也知道对应图像平面坐标的点。对于透视投影来说，要使得 PNP 问题有确定解，需要至少<strong>三组</strong>控制点。</p><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/Harry-hhj/Harry-hhj.github.io/master/_posts/2021-10-15-RM-Tutorial-5-Monocular-Vision.assets/516.png" alt="img" style="zoom:50%;" /></p><p>在解决任何 PnP 问题之前，我们都需要准确地<strong>标定</strong>出相机的内参矩阵和畸变矩阵，标定的质量会影响最后外参矩阵（旋转矩阵+平移矩阵）的精度。这一部分在之前的教程中已经教过了。</p><h3 id="1-p3p-问题">1. P3P 问题</h3><p>P3P 需要利用给定的 3 个点的几何关系。输入数据为 3 对 3D-2D 匹配点。记 3D 点为 A 、 B 、 C ， 2D 点为 a 、 b 、 c 。其中，小写字母代表点的为对应大写字母代表的点在相机成像平面上的投影。此外， P3P 还需要使用一对验证点，从可能的解中选出正确的那一个（验证点记为 D-d ），相机的光心为 O 。请注意，我们知道的是 ABC 三个点在世界坐标系中的坐标，而不是在相机坐标系中的坐标。</p><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/Harry-hhj/Harry-hhj.github.io/master/_posts/2021-10-15-RM-Tutorial-5-Monocular-Vision.assets/2019050515493252.png" alt="img" /></p><p>由图可得，显然有如下相似三角形的关系： \(\begin{cases} \triangle Oab \sim \triangle OAB \\ \triangle Obc \sim \triangle OBC \\ \triangle Oac \sim \triangle OAC \\ \end{cases}\) 采用余弦定理，有 \(\begin{cases} OA^2 + OB^2 - 2 \cdot OA \cdot OB \cos&lt;a, b&gt; = AB^2 \\ OB^2 + OC^2 - 2 \cdot OB \cdot OC \cos&lt;b, c&gt; = BC^2 \\ OA^2 + OC^2 - 2 \cdot OA \cdot OC \cos&lt;a, c&gt; = AC^2 \\ \end{cases}\) 左右两边同时除以 $OC^2$ ，令 $x = \cfrac{OA}{OC}, y = \cfrac{OB}{OC}$ ，有 \(\begin{cases} x^2 + y^2 - 2xy \cos&lt;a, b&gt; = \cfrac{AB^2}{OC^2} \\ y^2 + 1^2 + 2y \cos&lt;b, c&gt; = \cfrac{BC^2}{OC^2} \\ x^2 + 1^2 + 2x \cos&lt;a, c&gt; = \cfrac{AC^2}{OC^2} \\ \end{cases}\) 再令 $u = \cfrac{AB^2}{OC^2}, v = \cfrac{BC^2}{AB^2}, w = \cfrac{AC^2}{AB^2}$ ，有 \(\begin{cases} x^2 + y^2 - 2xy \cos&lt;a, b&gt; -v = 0 \\ y^2 + 1^2 + 2y \cos&lt;b, c&gt; - uv = 0 \\ x^2 + 1^2 + 2x \cos&lt;a, c&gt; - wv = 0 \\ \end{cases}\) 将第一个等式带入后面两个，得： \(\begin{cases} (1-u)y^2 - ux^2 - y \cos&lt;b, c&gt; + 2uxy \cos&lt;a, b&gt; + 1 = 0 \\ (1-w)x^2 - wy^2 - x \cos&lt;a, c&gt; + 2wxy \cos&lt;a, b&gt; + 1 = 0 \\ \end{cases}\) 2D 点的图像坐标已知， 3 个余弦角已知。 3D 点的坐标已知，只有 xy 未知。可以采用吴消元法来解上述方程。该方法最多可以获得 4 个解，但可以通过第四个点，来获得最可能的解。进一步地， <code class="language-plaintext highlighter-rouge">EPnP</code> （需要 4 对不共面的点）、 <code class="language-plaintext highlighter-rouge">UPnP</code> 等则是利用更多的信息来迭代，对相机的位姿进行优化，以尽可能消除噪声的影响。</p><p>至于进一步的运算这里就不推倒了，难度有点大，感兴趣的可以看<a href="https://blog.csdn.net/gwplovekimi/article/details/89844563">这篇博客</a>。</p><h3 id="2-pnp-问题">2. PnP 问题</h3><p>PnP 和 P3P 问题类似，但是它有足够的信息确定一组解。 PnP 算法通过至少四个点的约束，求出世界坐标系到相机坐标系的旋转矩阵和平移向量。 \(\begin{bmatrix} u\\ v\\ 1\\ \end{bmatrix} = \mathbf K \begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 1 &amp; 0 \\ \end{bmatrix} \begin{bmatrix} \mathbf R &amp; \mathbf T \\ \mathbf 0^T &amp; 1 \\ \end{bmatrix} \begin{bmatrix} X_w\\ Y_w\\ Z_w\\ 1\\ \end{bmatrix}\)</p><h3 id="3-opencv-中的-solvepnp">3. OpenCV 中的 <code class="language-plaintext highlighter-rouge">solvePnp()</code></h3><p>声明如下：</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span text-data=" Cpp "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="n">solvePnP</span><span class="p">(</span><span class="n">InputArray</span> <span class="n">objectPoints</span><span class="p">,</span> <span class="n">InputArray</span> <span class="n">imagePoints</span><span class="p">,</span> <span class="n">InputArray</span> <span class="n">cameraMatrix</span><span class="p">,</span> <span class="n">InputArray</span> <span class="n">distCoeffs</span><span class="p">,</span> <span class="n">OutputArray</span> <span class="n">rvec</span><span class="p">,</span> <span class="n">OutputArray</span> <span class="n">tvec</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">useExtrinsicGuess</span><span class="o">=</span><span class="nb">false</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="o">=</span><span class="n">CV_ITERATIVE</span><span class="p">)</span>
</pre></table></code></div></div><p>参数：</p><ul><li><code class="language-plaintext highlighter-rouge">objectPoints</code> ：视觉坐标系中的点<li><code class="language-plaintext highlighter-rouge">imagePoints</code> ：像素坐标系中的点<li><code class="language-plaintext highlighter-rouge">cameraMatrix</code> ：相机内参<li><code class="language-plaintext highlighter-rouge">disCoeffs</code> ：相机畸变矩阵<li><code class="language-plaintext highlighter-rouge">rvec</code> ：求出来的旋转向量<li><code class="language-plaintext highlighter-rouge">tvec</code> ：求出来的平移向量<li><code class="language-plaintext highlighter-rouge">useExtrinsicGuess</code>：是否输出平移矩阵和旋转矩阵，默认为 <code class="language-plaintext highlighter-rouge">false</code><li><code class="language-plaintext highlighter-rouge">flags</code> ：选择算法<ul><li><code class="language-plaintext highlighter-rouge">SOLVEPNP _ITERATIVE</code><li><code class="language-plaintext highlighter-rouge">SOLVEPNP _P3P</code><li><code class="language-plaintext highlighter-rouge">SOLVEPNP _EPNP</code><li><code class="language-plaintext highlighter-rouge">SOLVEPNP _DLS</code><li><code class="language-plaintext highlighter-rouge">SOLVEPNP _UPNP</code></ul></ul><p>如何用这函数来实现测距呢？我们只需要把世界坐标系的原点设置在我们感兴趣的点就可以了，那么函数返回的平移向量的的模长就是相机和那个点的距离。例如</p><p>TODO</p><h3 id="4-旋转角度旋转向量与旋转矩阵">4. 旋转角度、旋转向量与旋转矩阵</h3><p>我们再补充一下旋转矩阵和旋转响向量之间的转换关系。</p><p>三维空间中的旋转矩阵有 $9$ 个量，而三维空间中的旋转只有 $3$ 个自由度，因此我们很自然地想到， 是否可以用更少的量描述一个三维运动。</p><p>事实上，对于坐标系的旋转，任意旋转都可以用一个<strong>旋转轴</strong>和一个<strong>旋转角</strong>来刻画。于是，我们可以使用一个方向与旋转轴垂直、长度等于旋转角的向量描述旋转运动，这个向量成为旋转向量。</p><p>通过这样的方式，我们就可以只通过一个三维的旋转向量和一个三维的平移向量描述三维空间中刚体的运动。</p><p>旋转矩阵和旋转向量是可以互相转化的，有旋转向量推导旋转矩阵的公式也被成为罗德里格斯公式： \(\theta \leftarrow \norm{\vec{r}}\\ \vec{r} \leftarrow \vec{r}/\theta\\ R(\vec{n}, \theta) = \cos(\theta) \mathbf I + (1-\cos \theta)\vec{r}\vec{r}^T + \sin(\theta) \begin{bmatrix} 0 &amp; -r_z &amp; r_y \\ r_z &amp; 0 &amp; -r_x \\ -r_y &amp; r_x &amp; 0 \\ \end{bmatrix}\) 其中，旋转向量的长度（模）表示绕轴逆时针旋转的角度（弧度）， $\theta$ 表示旋转角度， $\mathbf{I}$ 表示单位矩阵，最后一个矩阵表示 $\vec r$ 的反对称矩阵。</p><p>旋转角 $\theta$ 也可以由公式 \(\theta = \arccos(\cfrac{tr(R)-1}{2})\) 计算得到。</p><p>OpenCV 中的旋转向量和旋转矩阵转换的函数是</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span text-data=" C++ "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">cvRodrigues2</span><span class="p">(</span> <span class="k">const</span> <span class="n">CvMat</span><span class="o">*</span> <span class="n">src</span><span class="p">,</span> <span class="n">CvMat</span><span class="o">*</span> <span class="n">dst</span><span class="p">,</span> <span class="n">CvMat</span><span class="o">*</span> <span class="n">jacobian</span><span class="o">=</span><span class="mi">0</span> <span class="p">);</span>
</pre></table></code></div></div><p>参数：</p><ul><li><code class="language-plaintext highlighter-rouge">src</code>：为输入的旋转向量（ $3\times1$ 或者 $1\times3$ ）或者旋转矩阵（ $3\times3$ ）。该参数向量表示其旋转的角度，用向量长度表示。<li><code class="language-plaintext highlighter-rouge">dst</code>：为输出的旋转矩阵（ $3\times3$ ）或者旋转向量（ $3\times1$ 或者 $1\times3$ ）。<li><code class="language-plaintext highlighter-rouge">jacobian</code>：为可选的输出雅可比矩阵（ $3\times9$ 或者 $9\times3$ ），是输入与输出数组的偏导数。</ul><p>例子如下：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span text-data=" C++ "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">r</span> <span class="o">=</span> <span class="p">(</span><span class="n">cv</span><span class="o">::</span><span class="n">Mat_</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="o">-</span><span class="mf">2.100418</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.167796</span><span class="p">,</span> <span class="mf">0.273330</span><span class="p">);</span>
<span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="nf">R</span><span class="p">(</span><span class="n">cv</span><span class="o">::</span><span class="n">Size</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="n">CV_16FC1</span><span class="p">);</span>
<span class="n">cv</span><span class="o">::</span><span class="n">Rodrigues</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">R</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"r="</span> <span class="o">&lt;&lt;</span> <span class="n">r</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"R="</span> <span class="o">&lt;&lt;</span> <span class="n">R</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</pre></table></code></div></div><p>程序结果：</p><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/Harry-hhj/Harry-hhj.github.io/master/_posts/2021-10-15-RM-Tutorial-5-Monocular-Vision.assets/image-20211023210217334.png" alt="image-20211023210217334" style="zoom:50%;" /></p><h3 id="5-欧拉角和四元数">5. 欧拉角和四元数</h3><h4 id="1欧拉角">（1）欧拉角</h4><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/Harry-hhj/Harry-hhj.github.io/master/_posts/2021-10-15-RM-Tutorial-5-Monocular-Vision.assets/image-20211025124356562.png" alt="image-20211025124356562" style="zoom:30%;" /></p><p>上图是一个示意图。欧拉角定义如下：</p><ul><li>绕物体的 z 轴旋转，得到偏航角 yaw<li>绕<strong>旋转之后</strong>的 y 轴旋转，得到俯仰角 pitch<li>绕<strong>旋转之后</strong>的 x 轴旋转，得到滚转角 roll</ul><p><strong>如果选用的轴的旋转顺序不同，则欧拉角不同。</strong>上述的欧拉角为 <strong>$rpy$ 欧拉角</strong>，以 $z$ 轴， $y$ 轴， $x$ 轴顺序旋转，是比较常用的一种。</p><p>下面举个例子（来自参考资料 5 ）。这里，我把三个 Gimbal 环用不同的颜色做了标记，底部三个轴向， RGB 分别对应 XYZ 。 假设现在这个陀螺仪被放在一艘船上，船头的方向沿着 +Z 轴，也就是蓝色右前方。</p><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/Harry-hhj/Harry-hhj.github.io/master/_posts/2021-10-15-RM-Tutorial-5-Monocular-Vision.assets/NorthEast.jpg" alt="陀螺仪示意图" /></p><p>现在假设，船体发生了摇晃，是沿着前方进行旋转的摇晃，也就是桶滚。由于转子和旋转轴具有较大的惯性，只要没有直接施加扭矩，就会保持原有的姿态。由于上图中绿色的活动的连接头处是可以灵活转动的，此时将发生相对旋转，从而出现以下的情形：</p><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/Harry-hhj/Harry-hhj.github.io/master/_posts/2021-10-15-RM-Tutorial-5-Monocular-Vision.assets/NorthEast.gif" alt="桶滚平衡" /></p><p>再次假设，船体发生了pitch摇晃，也就是俯仰。同样，由于存在相应方向的可以相对旋转的连接头（红色连接头），转子和旋转轴将仍然保持平衡，如下图：</p><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/Harry-hhj/Harry-hhj.github.io/master/_posts/2021-10-15-RM-Tutorial-5-Monocular-Vision.assets/NorthEast-20211025130945947.gif" alt="俯仰平衡" /></p><p>最后假设，船体发生了yaw摇晃，也就是偏航，此时船体在发生水平旋转。相对旋转发生在蓝色连接头。如下图：</p><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/Harry-hhj/Harry-hhj.github.io/master/_posts/2021-10-15-RM-Tutorial-5-Monocular-Vision.assets/NorthEast-20211025131005736.gif" alt="偏航平衡" /></p><p><strong>最终，在船体发生 Pitch 、 Yaw 、 Roll 的情况下，陀螺仪都可以通过自身的调节，而让转子和旋转轴保持平衡。</strong></p><p>但是欧拉角有一个致命的问题导致死锁，称为万向节死锁。</p><h4 id="2万向节死锁">（2）万向节死锁</h4><p>现在看起来，这个陀螺仪一切正常，在船体发生任意方向摇晃都可以通过自身调节来应对。然而，真的是这样吗？假如，船体发生了剧烈的变化，此时船首仰起了90度（虽然可能不合理），此时的陀螺仪调节状态如下图：</p><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/Harry-hhj/Harry-hhj.github.io/master/_posts/2021-10-15-RM-Tutorial-5-Monocular-Vision.assets/NorthEast-20211025131154268.jpg" alt="死锁开始" /></p><p>此时，船体再次发生转动，沿着当前世界坐标的 +Z 轴（蓝色轴，应该正指向船底）进行转动，那么来看看发生了什么情况。</p><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/Harry-hhj/Harry-hhj.github.io/master/_posts/2021-10-15-RM-Tutorial-5-Monocular-Vision.assets/NorthEast-20211025131214596.gif" alt="死锁的陀螺仪" /></p><p>现在，转子不平衡了，陀螺仪的三板斧不起作用了。它失去了自身的调节能力。那么这是为什么呢？</p><p>之前陀螺仪之所以能通过自身调节，保持平衡，是因为存在可以相对旋转的连接头。在这种情况下，已经不存在可以相对旋转的连接头了。 那么连接头呢？去了哪里？显然，它还是在那里，只不过是，连接头可以旋转的相对方向不是现在需要的按着+Z轴方向。从上图中，我们清楚地看到：</p><ul><li>红色连接头：可以给予一个相对俯仰的自由度。<li>绿色连接头：可以给予一个相对偏航的自由度。<li>蓝色连接头：可以给予一个相对偏航的自由度。</ul><p>没错，三个连接头，提供的自由度只对应了俯仰和偏航两个自由度，桶滚自由度丢失了。这就是陀螺仪上的“万向节死锁”问题。</p><p>我们可以用小程序来重现万向节死锁问题。首先，预设一下接下来的欧拉角变化顺序。见下图：</p><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/Harry-hhj/Harry-hhj.github.io/master/_posts/2021-10-15-RM-Tutorial-5-Monocular-Vision.assets/SouthEast.png" alt="预设欧拉旋转" /></p><p>上图中，红色框内的部分的列表，记录了接下来欧拉角的增长变化过程。即它会从 $(0,0,0)$ 变化到 $(90,0,0)$ ，再变化到 $(90,90,0)$ ，再变化到 $(90,180,0)$ ，再变化到 $(90,180,90)$ ，再变化到 $(90,180,180)$ 。下图是变化的过程演示：</p><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/Harry-hhj/Harry-hhj.github.io/master/_posts/2021-10-15-RM-Tutorial-5-Monocular-Vision.assets/SouthEast.gif" alt="YZ轴死锁" /></p><p>现在可以看到：</p><ul><li>当先执行X轴旋转 90 度，此时在执行Pitch(俯仰)变化。<li>再在Y轴进行变化 0-180 度，此时在执行相对自身的 Roll (桶滚)变化。<li>再在Z轴进行变化 0-180 度，此时仍在执行相对自身的 Roll (桶滚)变化。</ul><p>这里所说的俯仰、桶滚、偏航都是相对自己局部坐标系的。这与上述的陀螺仪中出现的问题是一样的，万向节死锁。也就是尽管欧拉角在 XYZ 三个轴向进行进动(持续增长或者减少)，但是影响最终的结果，只对应了两个轴向。这一点在 Unity 编程中也应该注意。</p><p>为了解决这一问题，我们引入四元数。由于万向锁的存在，欧拉角并不是一个完备的描述旋转的方式。事实上，我们找不到不带奇异性的三维向量描述方式。</p><h4 id="3四元数">（3）四元数</h4><p>四元数的定义如下： \(q = \begin{bmatrix}w &amp; x &amp; y &amp; z\\ \end{bmatrix}^T, \text{ where }|q|^2 = 1\) 定义 $\psi,\theta,\phi$ 分别为绕Z轴、Y轴、X轴的旋转角度，如果用 Tait-Bryan angle 表示，分别为 Yaw 、 Pitch 、 Roll 。</p><h5 id="旋转角度-四元数">旋转角度-&gt;四元数</h5><p>通过旋转轴和绕该轴旋转的角度可以构造一个四元数： \(w = \cos(\alpha/2)\\ x = \sin(\alpha/2)\cos(\beta_x)\\ y = \sin(\alpha/2)\cos(\beta_y)\\ z = \sin(\alpha/2)\cos(\beta_z)\\\) 其中 $\alpha$ 是绕旋转轴旋转的角度， $\cos(\beta_x),\cos(\beta_y),\cos(\beta_z)$ 为旋转轴在 $x,y,z$ 方向的分量（由此确定了旋转轴)。</p><h5 id="欧拉角-四元数">欧拉角-&gt;四元数</h5>\[q = \begin{bmatrix} w\\x\\y\\z\\ \end{bmatrix} = \begin{bmatrix} \cos(\phi/2)\cos(\theta/2)\cos(\psi/2)+\sin(\phi/2)\sin(\theta/2)\sin(\psi/2)\\ \sin(\phi/2)\cos(\theta/2)\cos(\psi/2)-\cos(\phi/2)\sin(\theta/2)\sin(\psi/2)\\ \cos(\phi/2)\sin(\theta/2)\cos(\psi/2)+\sin(\phi/2)\cos(\theta/2)\sin(\psi/2)\\ \cos(\phi/2)\cos(\theta/2)\sin(\psi/2)-\sin(\phi/2)\sin(\theta/2)\cos(\psi/2)\\ \end{bmatrix}\]<h5 id="四元数-欧拉角">四元数-&gt;欧拉角</h5>\[\begin{bmatrix} \phi\\\theta\\\psi \end{bmatrix} = \begin{bmatrix} \text{atan2}(2(wx+yz), 1-2(x^2+y^2))\\ \arcsin(2(wy-zx))\\ \text{atan2}(2(wz+xy), 1-2(y^2+z^2)) \end{bmatrix}\]<h5 id="其他坐标系">其他坐标系</h5><p>在其他坐标系下，需根据坐标轴的定义，调整一下以上公式。如在 Direct3D 中，笛卡尔坐标系的 X 轴变为 Z 轴， Y 轴变为 X 轴， Z 轴变为 Y 轴（无需考虑方向）。 \(q = \begin{bmatrix} w\\x\\y\\z\\ \end{bmatrix} = \begin{bmatrix} \cos(\phi/2)\cos(\theta/2)\cos(\psi/2)+\sin(\phi/2)\sin(\theta/2)\sin(\psi/2)\\ \cos(\phi/2)\sin(\theta/2)\cos(\psi/2)+\sin(\phi/2)\cos(\theta/2)\sin(\psi/2)\\ \cos(\phi/2)\cos(\theta/2)\sin(\psi/2)-\sin(\phi/2)\sin(\theta/2)\cos(\psi/2)\\ \sin(\phi/2)\cos(\theta/2)\cos(\psi/2)-\cos(\phi/2)\sin(\theta/2)\sin(\psi/2)\\ \end{bmatrix}\)</p>\[\begin{bmatrix} \phi\\\theta\\\psi \end{bmatrix} = \begin{bmatrix} \text{atan2}(2(wz+xy), 1-2(x^2+z^2))\\ \arcsin(2(wx-yz))\\ \text{atan2}(2(wy+xz), 1-2(x^2+y^2)) \end{bmatrix}\]<h2 id="三作业">三、作业</h2><p>链接: <em><a href="https://pan.baidu.com/s/19jWghlU5FS9YfwG4EcMADA">https://pan.baidu.com/s/19jWghlU5FS9YfwG4EcMADA</a></em> 提取码: q5bg</p><p>【其中部分题目提供了参考答案】</p><ol><li><p>对数据包中的汽车照片中的车牌进行透视变换，可自行决定难度：</p><ol><li>通过画图工具等手动确定透视变换 4 个像素点坐标<li>通过 OpenCV 窗口鼠标回调函数点击确定像素点坐标<li>通过传统视觉识别确定像素点坐标</ol><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/Harry-hhj/Harry-hhj.github.io/master/_posts/2021-10-15-RM-Tutorial-5-Monocular-Vision.assets/car.jpg" alt="car" /></p><li><p>项目实战：对桌面的扑克牌进行透视变换，给出扑克牌的正视图。要求用算法识别出角点并排序。</p><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/Harry-hhj/Harry-hhj.github.io/master/_posts/2021-10-15-RM-Tutorial-5-Monocular-Vision.assets/card.jpeg" alt="card" /></p><p>效果如下：</p><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/Harry-hhj/Harry-hhj.github.io/master/_posts/2021-10-15-RM-Tutorial-5-Monocular-Vision.assets/answer.jpg" alt="answer" /></p><li><p>使用 PnP 算法求解相机相对于标定板的位置，相机标定结果已经在数据包中给出与 <code class="language-plaintext highlighter-rouge">hw3.zip</code> 压缩包。</p><li><p>使用 OpenCV （与 Eigen ）完成深度图重投影，文件位于 <code class="language-plaintext highlighter-rouge">hw4.zip</code> 压缩包，其中包含了图片、其对应的深度信息、以及相机内参矩阵与相机透视变换矩阵。</p></ol><p><br /></p><p><strong>如果觉得本教程不错或对您有用，请前往项目地址 <a href="https://github.com/Harry-hhj/Harry-hhj.github.io">https://github.com/Harry-hhj/Harry-hhj.github.io</a> 点击 Star :) ，这将是对我的肯定和鼓励，谢谢！</strong></p><p><br /></p><h2 id="四参考资料">四、参考资料</h2><ol><li><a href="https://www.zhihu.com/question/20666664">如何通俗地讲解「仿射变换」这个概念？</a><li><a href="https://blog.csdn.net/Needlyr/article/details/75127370">仿射变换</a><li><a href="https://blog.csdn.net/gwplovekimi/article/details/89844563">学习笔记之——P3P与ICP位姿估计算法及实验</a><li><a href="https://www.zhihu.com/question/28571059">Eigen的速度为什么这么快？</a>（部分代码有误）<li><a href="https://blog.csdn.net/andrewfan/article/details/60981437">【Unity编程】欧拉角与万向节死锁（图文版）</a><li><a href="http://www.cppblog.com/heath/archive/2009/12/13/103127.html">学习笔记—四元数与欧拉角之间的转换</a></ol><hr /><p>作者：Harry-hhj，Github主页：<a href="https://github.com/Harry-hhj">传送门</a></p><p>作者：E-T-E-R-N-A-L-B-L-U-E，<a href="https://github.com/E-T-E-R-N-A-L-B-L-U-E">传送门</a></p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/course/'>Course</a>, <a href='/categories/rm/'>RM</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/getting-started/" class="post-tag no-text-decoration" >getting started</a> <a href="/tags/robomaster/" class="post-tag no-text-decoration" >robomaster</a> <a href="/tags/computer-vision/" class="post-tag no-text-decoration" >computer vision</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=RM 教程 5 —— 单目视觉 - Harry's Blog&url=https://harry-hhj.github.io/posts/RM-Tutorial-5-Monocular-Vision/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=RM 教程 5 —— 单目视觉 - Harry's Blog&u=https://harry-hhj.github.io/posts/RM-Tutorial-5-Monocular-Vision/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=RM 教程 5 —— 单目视觉 - Harry's Blog&url=https://harry-hhj.github.io/posts/RM-Tutorial-5-Monocular-Vision/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/RM-Tutorial-5-Monocular-Vision/">RM 教程 5 —— 单目视觉</a><li><a href="/posts/RM-Tutorial-Catalogue/">RoboMaster 课程目录</a><li><a href="/posts/NN-Tutorial-Catalogue/">神经网络课程目录</a><li><a href="/posts/RM-Tutorial-3-Getting-Started-with-OpenCV/">RM 教程 3 —— OpenCV 传统视觉</a><li><a href="/posts/RM-Tutorial-4-Camera/">RM 教程 4 —— 相机</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/getting-started/">getting started</a> <a class="post-tag" href="/tags/install/">install</a> <a class="post-tag" href="/tags/robomaster/">robomaster</a> <a class="post-tag" href="/tags/computer-science/">computer science</a> <a class="post-tag" href="/tags/tools/">tools</a> <a class="post-tag" href="/tags/catalog/">catalog</a> <a class="post-tag" href="/tags/opencv/">opencv</a> <a class="post-tag" href="/tags/pytorch/">pytorch</a> <a class="post-tag" href="/tags/c-c/">c/c++</a> <a class="post-tag" href="/tags/camera/">camera</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/RM-Tutorial-1-Linux-Introduction/"><div class="card-body"> <span class="timeago small" >Sep 24<i class="unloaded">2021-09-24T16:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>RM 教程 1 —— Linux 教程</h3><div class="text-muted small"><p> RM 教程 1 —— Linux 教程 机械是血肉，电控是大脑，视觉是灵魂。 一、Why Linux &amp; Why Ubuntu Ubuntu 是一个十分流行并且好用的 Linux 桌面发行版本。截止到目前，Ubuntu 已经发行了 Ubuntu 20.04 的版本，并且其稳定性和支持已经很不错了。你可以在这里下载各个版本的 Ubuntu 系统镜像文件，虚拟机的话一般...</p></div></div></a></div><div class="card"> <a href="/posts/RM-Tutorial-2-Install-OpenCV/"><div class="card-body"> <span class="timeago small" >Oct 2<i class="unloaded">2021-10-02T13:30:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>RM 教程 2 —— 安装 OpenCV</h3><div class="text-muted small"><p> RM 教程 2 —— 安装 OpenCV 机械是血肉，电控是大脑，视觉是灵魂。 一、简介 OpenCV 是计算机视觉中经典的专用库，其支持多语言，跨平台，功能强大。 opencv-python 为OpenCV 提供了 Python 接口，使得使用者在 Python 中能够调用 C/C++ ，在保证易读性和运行效率的前提下，实现所需的功能。 OpenCV 现在支持与计算机视...</p></div></div></a></div><div class="card"> <a href="/posts/RM-Tutorial-3-Getting-Started-with-OpenCV/"><div class="card-body"> <span class="timeago small" >Oct 2<i class="unloaded">2021-10-02T18:05:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>RM 教程 3 —— OpenCV 传统视觉</h3><div class="text-muted small"><p> RM 教程 3 —— OpenCV 传统视觉 机械是血肉，电控是大脑，视觉是灵魂。 本片教程主要集中于边缘及轮廓检测。 一、OpenCV 基本组件 - Mat Mat 是 OpenCV 中常用的基本类型，即矩阵类。在计算机内存中，数字图像以矩阵的形式存储和运算，因此 OpenCV 中常常用 Mat 储存图像数据。 Mat 本质上由两个数据部分组成：矩阵头和一个指向像素数...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/Numpy-Tutorial/" class="btn btn-outline-primary" prompt="Older"><p>神经网络集训 —— Numpy 的使用</p></a> <a href="/posts/Unreal-Engine-Tutorial-Catalogue/" class="btn btn-outline-primary" prompt="Newer"><p>Unreal Engine 4 课程目录</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2021 <a href="https://github.com/Harry-hhj">HHJ</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/getting-started/">getting started</a> <a class="post-tag" href="/tags/install/">install</a> <a class="post-tag" href="/tags/robomaster/">robomaster</a> <a class="post-tag" href="/tags/computer-science/">computer science</a> <a class="post-tag" href="/tags/tools/">tools</a> <a class="post-tag" href="/tags/catalog/">catalog</a> <a class="post-tag" href="/tags/opencv/">opencv</a> <a class="post-tag" href="/tags/pytorch/">pytorch</a> <a class="post-tag" href="/tags/c-c/">c/c++</a> <a class="post-tag" href="/tags/camera/">camera</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script> /* see: <https://docs.mathjax.org/en/latest/options/input/tex.html#tex-options> */ MathJax = { tex: { inlineMath: [ /* start/end delimiter pairs for in-line math */ ['$','$'], ['\\(','\\)'] ], displayMath: [ /* start/end delimiter pairs for display math */ ['$$', '$$'], ['\\[', '\\]'] ] } }; </script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"> </script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script>

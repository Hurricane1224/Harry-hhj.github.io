<!DOCTYPE html><html lang="zh" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content="days ago"><meta name="hour-prompt" content="hours ago"><meta name="minute-prompt" content="minutes ago"><meta name="justnow-prompt" content="just now"><meta name="generator" content="Jekyll v4.2.1" /><meta property="og:title" content="神经网络集训 —— Numpy 的使用" /><meta name="author" content="Harry-hhj" /><meta property="og:locale" content="zh" /><meta name="description" content="神经网络集训 —— Numpy 的使用" /><meta property="og:description" content="神经网络集训 —— Numpy 的使用" /><link rel="canonical" href="https://harry-hhj.github.io/posts/Numpy-Tutorial/" /><meta property="og:url" content="https://harry-hhj.github.io/posts/Numpy-Tutorial/" /><meta property="og:site_name" content="Harry’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-10-14T22:00:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="神经网络集训 —— Numpy 的使用" /><meta name="twitter:site" content="@None" /><meta name="twitter:creator" content="@Harry-hhj" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"author":{"@type":"Person","name":"Harry-hhj"},"description":"神经网络集训 —— Numpy 的使用","url":"https://harry-hhj.github.io/posts/Numpy-Tutorial/","@type":"BlogPosting","headline":"神经网络集训 —— Numpy 的使用","dateModified":"2021-10-20T00:32:13+08:00","datePublished":"2021-10-14T22:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://harry-hhj.github.io/posts/Numpy-Tutorial/"},"@context":"https://schema.org"}</script><title>神经网络集训 —— Numpy 的使用 | Harry's Blog</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Harry's Blog"><meta name="application-name" content="Harry's Blog"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script> var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?f40851b91841f1abe810a63f8d41c2e2"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })(); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end" lang="en"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/avatar/avatar.jpeg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Harry's Blog</a></div><div class="site-subtitle font-italic">Write blogs, share ideas, make friends and enjoy life.</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <a href="https://github.com/Harry-hhj" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['Harry_hhj','163.com'].join('@')" aria-label="email" class="order-4" > <i class="fas fa-envelope"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>神经网络集训 —— Numpy 的使用</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>神经网络集训 —— Numpy 的使用</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Harry-hhj </span> on <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Thu, Oct 14, 2021, 10:00 PM +0800" >Oct 14<i class="unloaded">2021-10-14T22:00:00+08:00</i> </span></div><div> <span> Updated <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Wed, Oct 20, 2021, 12:32 AM +0800" >Oct 20<i class="unloaded">2021-10-20T00:32:13+08:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="6271 words">34 min read</span></div></div><div class="post-content"> <img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 639 639'%3E%3C/svg%3E" data-proofer-ignore data-src="https://raw.githubusercontent.com/Harry-hhj/Harry-hhj.github.io/master/_posts/2021-10-14-Numpy-Tutorial.assets/IMG_4633.JPG" class="preview-img" alt="Preview Image" width="639" height="639"><h1 id="神经网络集训--numpy-的使用">神经网络集训 —— Numpy 的使用</h1><p>在讲解具体的知识点之前，先来做做以下的问卷，进行一个基础的自查。这样，既能避免过分地自信导致学习态度的降低，也能有针对性地学习自己不理解的知识。当然，<strong>做题时请不要借助外部资料！</strong></p><p>链接: <em><a href="https://pan.baidu.com/s/1Ip4Dz6sAel3htlETxWbOYg">https://pan.baidu.com/s/1Ip4Dz6sAel3htlETxWbOYg</a></em> 提取码: op3f</p><h2 id="一python-基础">一、Python 基础</h2><h3 id="1import-机制">（1）import 机制</h3><p>对于 Python 脚本， <code class="language-plaintext highlighter-rouge">import</code> 的顺序不同，运行脚本不同，程序执行的代码可能不同，结果自然也不会相同。</p><p>我们来看以下三个脚本：</p><p><code class="language-plaintext highlighter-rouge">A.py</code> ：</p><div class="language-python highlighter-rouge"><div class="code-header"> <span text-data=" Python "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="c1"># A.py
</span><span class="n">x</span><span class="o">=</span><span class="mi">1</span>
<span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">val</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">B.py</code> ：</p><div class="language-python highlighter-rouge"><div class="code-header"> <span text-data=" Python "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="c1"># B.py
</span><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
<span class="n">func</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="kn">import</span> <span class="nn">A</span>
<span class="n">A</span><span class="p">.</span><span class="n">func</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">C.py</code> ：</p><div class="language-python highlighter-rouge"><div class="code-header"> <span text-data=" Python "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="c1"># C.py
</span><span class="kn">import</span> <span class="nn">A</span>
<span class="n">A</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">10</span>

<span class="kn">import</span> <span class="nn">B</span>
<span class="n">B</span><span class="p">.</span><span class="n">func</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">x</span><span class="p">)</span>
</pre></table></code></div></div><p>那么 <code class="language-plaintext highlighter-rouge">C.py</code> 的运行结果是：</p><div class="language-text highlighter-rouge"><div class="code-header"> <span text-data=" Text "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>4
1
2
2
10
</pre></table></code></div></div><p>为什么最后是 10 而不是 5 ？原因在于 python 的 import 机制。</p><h4 id="1标准-import">1）标准 import</h4><p>Python 中所有加载到内存的模块都放在 <code class="language-plaintext highlighter-rouge">sys.modules</code> 。当 <code class="language-plaintext highlighter-rouge">import</code> 一个模块时首先会在这个列表中查找是否已经加载了此模块，如果加载了则只是将模块的名字加入到正在调用 <code class="language-plaintext highlighter-rouge">import</code> 的模块的 Local 名字空间中。如果没有加载则从 <code class="language-plaintext highlighter-rouge">sys.path</code> 目录中按照模块名称查找模块文件，模块可以是 <code class="language-plaintext highlighter-rouge">py</code> 、 <code class="language-plaintext highlighter-rouge">pyc</code> 、 <code class="language-plaintext highlighter-rouge">pyd</code> ，找到后将模块载入内存，并加到 <code class="language-plaintext highlighter-rouge">sys.modules</code> 中，并将名称导入到当前的 Local 名字空间。</p><p><strong>一个模块不会重复载入。</strong>多个不同的模块都可以用 <code class="language-plaintext highlighter-rouge">import</code> 引入同一个模块到自己的 Local 名字空间，其实背后的 <code class="language-plaintext highlighter-rouge">PyModuleObject</code> 对象只有一个。这里说一个容易忽略的问题： <code class="language-plaintext highlighter-rouge">import</code> 只能导入模块，不能导入模块中的对象（类、函数、变量等）。例如：模块 <code class="language-plaintext highlighter-rouge">A</code>（<code class="language-plaintext highlighter-rouge">A.py</code>）中有个函数 <code class="language-plaintext highlighter-rouge">getName</code> ，另一个模块不能通过 <code class="language-plaintext highlighter-rouge">import A.getName</code> 将 <code class="language-plaintext highlighter-rouge">getName</code> 导入到本模块，只能用 <code class="language-plaintext highlighter-rouge">from A import getName</code> 。</p><p>注意，虽然有一种写法 <code class="language-plaintext highlighter-rouge">from A import *</code> 可以一次性导入模块中的所有对象，但是我们无法确保所有模块的对象不重名，可能会造成内存覆盖的问题，这在项目中非常难 debug ，所以<strong>不要使用</strong>！</p><h4 id="2嵌套-import">2）嵌套 import</h4><h5 id="1-顺序嵌套">1. 顺序嵌套</h5><p>例如：本模块导入 <code class="language-plaintext highlighter-rouge">A</code> 模块（<code class="language-plaintext highlighter-rouge">import A</code>）， <code class="language-plaintext highlighter-rouge">A</code> 中又 <code class="language-plaintext highlighter-rouge">import B</code> ， <code class="language-plaintext highlighter-rouge">B</code> 模块又可以 <code class="language-plaintext highlighter-rouge">import C</code> ……</p><p>这中嵌套比较容易理解，需要注意的一点就是<strong>各个模块的 Local 名字空间是独立的</strong>。对于上面的例子，本模块 <code class="language-plaintext highlighter-rouge">import A</code> 之后本模块只能访问模块 <code class="language-plaintext highlighter-rouge">A</code> ，不能访问模块 <code class="language-plaintext highlighter-rouge">B</code> 及其他模块。虽然模块 <code class="language-plaintext highlighter-rouge">B</code> 已经加载到内存了，如果访问还要再明确的在本模块中 <code class="language-plaintext highlighter-rouge">import B</code> 。</p><h5 id="2-循环嵌套">2. 循环嵌套</h5><p>举个例子：</p><div class="language-python highlighter-rouge"><div class="code-header"> <span text-data=" Python "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="c1"># A.py
</span><span class="kn">from</span> <span class="nn">B</span> <span class="kn">import</span> <span class="n">D</span>
<span class="k">class</span> <span class="nc">C</span><span class="p">:</span> <span class="k">pass</span>
</pre></table></code></div></div><div class="language-python highlighter-rouge"><div class="code-header"> <span text-data=" Python "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="c1"># B.py
</span><span class="kn">from</span> <span class="nn">A</span> <span class="kn">import</span> <span class="n">C</span>
<span class="k">class</span> <span class="nc">D</span><span class="p">:</span> <span class="k">pass</span>
</pre></table></code></div></div><p>结果会报错 <code class="language-plaintext highlighter-rouge">ImportError: cannot import name 'D' from partially initialized module 'B' (most likely due to a circular import)</code> 。如果将 <code class="language-plaintext highlighter-rouge">A.py</code> 改为： <code class="language-plaintext highlighter-rouge">import B</code> 就可以了。为什么？</p><p>这跟 Python 内部 <code class="language-plaintext highlighter-rouge">import</code> 的机制是有关的，具体到 <code class="language-plaintext highlighter-rouge">from B import D</code> ， Python 内部会分成几个步骤：</p><ol><li>在 <code class="language-plaintext highlighter-rouge">sys.modules</code> 中查找符号 <code class="language-plaintext highlighter-rouge">“B”</code><li>如果符号 <code class="language-plaintext highlighter-rouge">B</code> 存在，则获得符号 <code class="language-plaintext highlighter-rouge">B</code> 对应的 <code class="language-plaintext highlighter-rouge">module</code> 对象。从 <modult B=""> 的 `__dict__` 中获得符号 `“D”` 对应的对象，如果 `“D”` 不存在，则抛出异常。</modult><li>如果符号 <code class="language-plaintext highlighter-rouge">B</code> 不存在，则创建一个新的 <code class="language-plaintext highlighter-rouge">module</code> 对象 <code class="language-plaintext highlighter-rouge">&lt;module B&gt;</code>，注意，此时， <code class="language-plaintext highlighter-rouge">module</code> 对象的 <code class="language-plaintext highlighter-rouge">__dict__</code> 为空。执行 <code class="language-plaintext highlighter-rouge">B.py</code> 中的表达式，填充 <code class="language-plaintext highlighter-rouge">&lt;module B&gt;</code> 的 <code class="language-plaintext highlighter-rouge">__dict__</code> 。从 <code class="language-plaintext highlighter-rouge">&lt;module B&gt;</code> 的 <code class="language-plaintext highlighter-rouge">__dict__</code> 中获得 <code class="language-plaintext highlighter-rouge">“D”</code> 对应的对象，如果 <code class="language-plaintext highlighter-rouge">“D”</code> 不存在，则抛出异常。</ol><p>所以这个例子的执行顺序如下：</p><ol><li><p>执行 <code class="language-plaintext highlighter-rouge">A.py</code> 中的 <code class="language-plaintext highlighter-rouge">from B import D</code> 由于是执行的 <code class="language-plaintext highlighter-rouge">python A.py</code> ，所以在 <code class="language-plaintext highlighter-rouge">sys.modules</code> 中并没有 <code class="language-plaintext highlighter-rouge">&lt;module B&gt;</code> 存在， 首先为 <code class="language-plaintext highlighter-rouge">B.py</code> 创建一个 <code class="language-plaintext highlighter-rouge">module</code> 对象 (<code class="language-plaintext highlighter-rouge">&lt;module B&gt;</code>) ， 注意，这时创建的这个 <code class="language-plaintext highlighter-rouge">module</code> 对象是空的，里边啥也没有，在 Python 内部创建了这个 <code class="language-plaintext highlighter-rouge">module</code> 对象之后，就会解析执行 <code class="language-plaintext highlighter-rouge">B.py</code> ，其目的是填充 <code class="language-plaintext highlighter-rouge">&lt;module B&gt;</code> 这个 <code class="language-plaintext highlighter-rouge">__dict__</code> 。</p><li><p>执行 <code class="language-plaintext highlighter-rouge">B.py</code> 中的 <code class="language-plaintext highlighter-rouge">from A import C</code> 在执行 <code class="language-plaintext highlighter-rouge">B.py</code> 的过程中，会碰到这一句， 首先检查 <code class="language-plaintext highlighter-rouge">sys.modules</code> 这个 <code class="language-plaintext highlighter-rouge">module</code> 缓存中是否已经存在 <code class="language-plaintext highlighter-rouge">&lt;module A&gt;</code> 了， 由于这时缓存还没有缓存 <code class="language-plaintext highlighter-rouge">&lt;module A&gt;</code> ， 所以类似的，Python 内部会为 <code class="language-plaintext highlighter-rouge">A.py</code> 创建一个 module 对象(<code class="language-plaintext highlighter-rouge">&lt;module A&gt;</code>)， 然后，同样地，执行 <code class="language-plaintext highlighter-rouge">A.py</code> 中的语句。</p><li><p>再次执行 <code class="language-plaintext highlighter-rouge">A.py</code> 中的 <code class="language-plaintext highlighter-rouge">from B import D</code> 这时，由于在第 1 步时，创建的 <code class="language-plaintext highlighter-rouge">&lt;module B&gt;</code> 对象已经缓存在了 <code class="language-plaintext highlighter-rouge">sys.modules</code> 中， 所以直接就得到了 <code class="language-plaintext highlighter-rouge">&lt;module B&gt;</code> ， 但是，注意，从整个过程来看，我们知道，这时 <code class="language-plaintext highlighter-rouge">&lt;module B&gt;</code> 还是一个空的对象，里面啥也没有， 所以从这个 <code class="language-plaintext highlighter-rouge">module</code> 中获得符号 <code class="language-plaintext highlighter-rouge">"D"</code> 的操作就会抛出异常。 如果这里只是 <code class="language-plaintext highlighter-rouge">import B</code> ，由于 <code class="language-plaintext highlighter-rouge">"B"</code> 这个符号在 <code class="language-plaintext highlighter-rouge">sys.modules</code> 中已经存在，所以是不会抛出异常的。</p><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/Harry-hhj/Harry-hhj.github.io/master/_posts/2021-10-14-Numpy-Tutorial.assets/150102114196901.jpg" alt="150102114196901" /></p></ol><h5 id="3包-import">3）包 import</h5><p>只要一个文件夹下面有个 <code class="language-plaintext highlighter-rouge">__init__.py</code> 文件，那么这个文件夹就可以看做是一个包。包导入的过程和模块的基本一致，只是导入包的时候会执行此包目录下的 <code class="language-plaintext highlighter-rouge">__init__.py</code> 而不是模块里面的语句了。另外，如果只是单纯的导入包，而<strong>包的 <code class="language-plaintext highlighter-rouge">__init__.py</code> 中又没有明确的其他初始化操作，那么此包下面的模块是不会自动导入的。</strong></p><p>例如</p><p>有下面的包结构：</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span text-data=" Shell "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre>PA
|---- __init__.py
|---- wave.py
|---- PB1
      |---- __init__.py
      |---- pb1_m.py
|---- PB2
      |---- __init__.py
      |---- pb2_m.py
</pre></table></code></div></div><p>有如下程序：</p><div class="language-python highlighter-rouge"><div class="code-header"> <span text-data=" Python "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">PA.wave</span>						 <span class="c1">#1
</span><span class="kn">import</span> <span class="nn">PA.PB1</span>							 <span class="c1">#2
</span><span class="kn">import</span> <span class="nn">PA.PB1.pb1_m</span> <span class="k">as</span> <span class="n">m1</span>		 <span class="c1">#3
</span><span class="kn">import</span> <span class="nn">PA.PB2.pb2_m</span>					<span class="c1">#4
</span><span class="n">PA</span><span class="p">.</span><span class="n">wave</span><span class="p">.</span><span class="n">getName</span><span class="p">()</span>					  <span class="c1">#5
</span><span class="n">m1</span><span class="p">.</span><span class="n">getName</span><span class="p">()</span>							 <span class="c1">#6
</span><span class="n">PA</span><span class="p">.</span><span class="n">PB</span><span class="p">.</span><span class="n">pb2_m</span><span class="p">.</span><span class="n">getName</span><span class="p">()</span>				<span class="c1">#7
</span></pre></table></code></div></div><p>程序执行过程如下：</p><ol><li>当执行 <code class="language-plaintext highlighter-rouge">#1</code> 后， <code class="language-plaintext highlighter-rouge">sys.modules</code> 会同时存在 <code class="language-plaintext highlighter-rouge">PA</code> 、 <code class="language-plaintext highlighter-rouge">PA.wave</code> 两个模块，此时可以调用 <code class="language-plaintext highlighter-rouge">PA.wave</code> 的任何类或函数了。不能调用 <code class="language-plaintext highlighter-rouge">PA.PB1(2)</code> 下的任何模块。当前 <code class="language-plaintext highlighter-rouge">Local</code> 中有了 <code class="language-plaintext highlighter-rouge">PA</code> 名字。<li>当执行 <code class="language-plaintext highlighter-rouge">#2</code> 后，只是将 <code class="language-plaintext highlighter-rouge">PA.PB1</code> 载入内存， <code class="language-plaintext highlighter-rouge">sys.modules</code> 中会有 <code class="language-plaintext highlighter-rouge">PA</code> 、 <code class="language-plaintext highlighter-rouge">PA.wave</code> 、 <code class="language-plaintext highlighter-rouge">PA.PB1</code> 三个模块，但是 <code class="language-plaintext highlighter-rouge">PA.PB1</code> 下的任何模块都没有自动载入内存，此时如果直接执行 <code class="language-plaintext highlighter-rouge">PA.PB1.pb1_m.getName()</code> 则会出错，因为 <code class="language-plaintext highlighter-rouge">PA.PB1</code> 中并没有 <code class="language-plaintext highlighter-rouge">pb1_m</code> 。当前 <code class="language-plaintext highlighter-rouge">Local</code> 中还是只有 <code class="language-plaintext highlighter-rouge">PA</code> 名字，并没有 <code class="language-plaintext highlighter-rouge">PA.PB1</code> 名字。<li>当执行 <code class="language-plaintext highlighter-rouge">#3</code> 后，会将 <code class="language-plaintext highlighter-rouge">PA.PB1</code> 下的 <code class="language-plaintext highlighter-rouge">pb1_m</code> 载入内存， <code class="language-plaintext highlighter-rouge">sys.modules</code> 中会有 <code class="language-plaintext highlighter-rouge">PA</code> 、 <code class="language-plaintext highlighter-rouge">PA.wave</code> 、 <code class="language-plaintext highlighter-rouge">PA.PB1</code> 、 <code class="language-plaintext highlighter-rouge">PA.PB1.pb1_m</code> 四个模块，此时可以执行 <code class="language-plaintext highlighter-rouge">PA.PB1.pb1_m.getName()</code> 了。由于使用了 <code class="language-plaintext highlighter-rouge">as</code> ，当前 Local 中除了 <code class="language-plaintext highlighter-rouge">PA</code> 名字，另外添加了 <code class="language-plaintext highlighter-rouge">m1</code> 作为 <code class="language-plaintext highlighter-rouge">PA.PB1.pb1_m</code> 的别名。<li>当执行 <code class="language-plaintext highlighter-rouge">#4</code> 后，会将 <code class="language-plaintext highlighter-rouge">PA.PB2</code> 、 <code class="language-plaintext highlighter-rouge">PA.PB2.pb2_m</code> 载入内存， <code class="language-plaintext highlighter-rouge">sys.modules</code> 中会有 <code class="language-plaintext highlighter-rouge">PA</code> 、 <code class="language-plaintext highlighter-rouge">PA.wave</code> 、 <code class="language-plaintext highlighter-rouge">PA.PB1</code> 、 <code class="language-plaintext highlighter-rouge">PA.PB1.pb1_m</code> 、 <code class="language-plaintext highlighter-rouge">PA.PB2</code> 、 <code class="language-plaintext highlighter-rouge">PA.PB2.pb2_m</code> 六个模块。当前 <code class="language-plaintext highlighter-rouge">Local</code> 中还是只有 <code class="language-plaintext highlighter-rouge">PA</code> 、 <code class="language-plaintext highlighter-rouge">m1</code> 。<li>下面的 <code class="language-plaintext highlighter-rouge">#5</code> ， <code class="language-plaintext highlighter-rouge">#6</code> ， <code class="language-plaintext highlighter-rouge">#7</code> 都是可以正确运行的。</ol><p>注意的是：如果 <code class="language-plaintext highlighter-rouge">PA.PB2.pb2_m</code> 想导入 <code class="language-plaintext highlighter-rouge">PA.PB1.pb1_m</code> 、 <code class="language-plaintext highlighter-rouge">PA.wave</code> 是可以直接成功的。最好是采用明确的导入路径，对于<code class="language-plaintext highlighter-rouge"> ./..</code> 相对导入路径还是不推荐用。</p><h3 id="2避免使用全局表达式">（2）避免使用全局表达式</h3><p>一个模块中定义的全局变量一般是可以被其他模块所修改的，比如之前的例子中，模块 <code class="language-plaintext highlighter-rouge">B</code> 相信 <code class="language-plaintext highlighter-rouge">A.x</code> 值是 <code class="language-plaintext highlighter-rouge">1</code> ，但是它不知道在 <code class="language-plaintext highlighter-rouge">C.py</code> 中已经对它进行了修改。<strong>这些修改直接修改变量值的操作都应该放在 <code class="language-plaintext highlighter-rouge">if __name__ == '__main__':</code> 中。</strong></p><p><code class="language-plaintext highlighter-rouge">if __name__ == '__main__':</code> 是指在终端运行该 python 脚本时才会执行的语句，除此之外的所有情况下这些代码都不会执行。</p><h3 id="3变量含义">（3）变量含义</h3><p>在 Python 中<strong>所有的变量名都是一个符号</strong>，其实现是<strong>将变量名和它的值绑定</strong>。 <strong><code class="language-plaintext highlighter-rouge">=</code> 号并不代表赋值，而是重新将一个变量名与新的值进行绑定。</strong>有了这个理解，你就会对下面的示例有更好地理解：</p><div class="language-python highlighter-rouge"><div class="code-header"> <span text-data=" Python "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">func1</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="n">a</span> <span class="o">=</span> <span class="s">"world"</span>
<span class="k">def</span> <span class="nf">func2</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s">"world"</span>

<span class="n">x</span> <span class="o">=</span> <span class="s">"hello"</span>
<span class="n">func1</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="s">"hello"</span><span class="p">]</span>
<span class="n">func2</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></table></code></div></div><p>在 <code class="language-plaintext highlighter-rouge">func1</code> 中，调用时先将 <code class="language-plaintext highlighter-rouge">x</code> 的值同时绑定到参数 <code class="language-plaintext highlighter-rouge">a</code> 上，然后将 <code class="language-plaintext highlighter-rouge">a</code> 重新绑定到常量 <code class="language-plaintext highlighter-rouge">“world”</code> 上，这并不影响 <code class="language-plaintext highlighter-rouge">x</code> 绑定在 <code class="language-plaintext highlighter-rouge">"hello"</code> 上。</p><p>而在 <code class="language-plaintext highlighter-rouge">func2</code> 中，调用时先将 <code class="language-plaintext highlighter-rouge">x</code> 的值（数组）同时绑定到参数 <code class="language-plaintext highlighter-rouge">a</code> 上，然后将这个数组的第 0 个数据指向常量 <code class="language-plaintext highlighter-rouge">“world”</code> 上，这时 <code class="language-plaintext highlighter-rouge">x</code> 绑定的值也发生了变化。</p><p>如果你有 C/C++ 基础，你可以把所有变量符号想象成一个指针， <code class="language-plaintext highlighter-rouge">=</code> 的右操作数就是指针要指向的对象，而 <code class="language-plaintext highlighter-rouge">=</code> 就是对指针赋值的过程。</p><h3 id="4原地运算">（4）原地运算</h3><p>在 Python 中，一些运算是返回备份的，而另一些是直接修改原值的，叫做原地运算。这些运算很多，不可能一一枚举，但我们需要有这样一个概念。</p><p>例如下面的函数：</p><div class="language-python highlighter-rouge"><div class="code-header"> <span text-data=" Python "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">minus_one</span><span class="p">(</span><span class="n">minuend</span><span class="p">):</span>
  <span class="n">minuend</span> <span class="o">-=</span> <span class="mi">1</span>
</pre></table></code></div></div><p>如果你没有办法区分这个函数是否可以直接修改调用时传入的参数值，那么<strong>我们推荐将所有函数写成 <code class="language-plaintext highlighter-rouge">return</code> 的形式返回运算结果</strong>。</p><div class="language-python highlighter-rouge"><div class="code-header"> <span text-data=" Python "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">minus_one</span><span class="p">(</span><span class="n">minuend</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">minuend</span> <span class="o">-</span> <span class="mi">1</span>

<span class="n">x</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">minus_one</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></table></code></div></div><h2 id="二numpy-基础">二、Numpy 基础</h2><h3 id="0广播-broadcasting">（0）广播 （broadcasting）</h3><p>在讲解 Numpy 运算之前，我们先要讲一个非常有用的机制——广播（broadcasting），它能自动将两个大小不等的张量通过<strong>复制扩展</strong>自动变成两个相同大小的张量然后进行运算。尽管它非常有用，但是它也是程序没有报错却也运行结果不对的杀手！（因为程序不会报错，因此你可以使用 <code class="language-plaintext highlighter-rouge">assert</code> 确保程序符合你的想法）</p><p>广播用于对应元素的二元运算，如<code class="language-plaintext highlighter-rouge">+-*/</code>等。对应元素的二元运算一般要求两个张量的shape相同，当shape不同时，会触发广播。</p><p>广播的原则：<strong>如果两个数组的后缘维度（trailing dimension，即从末尾开始算起的维度）的轴长度相符，或其中的一方的长度为 1 ，则认为它们是广播兼容的。</strong></p><h4 id="1-后缘维度的轴长相符">1. 后缘维度的轴长相符</h4><div class="language-python highlighter-rouge"><div class="code-header"> <span text-data=" Python "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>  
<span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>    
<span class="k">print</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span>
</pre></table></code></div></div><p>上例中 x 的shape为 $(4, 3)$ ，y 的shape 为 $(3, )$ 。虽然前者是一维的，后者是二维的，但是比较后缘维度可知：</p><div class="language-python highlighter-rouge"><div class="code-header"> <span text-data=" Python "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
   <span class="o">^</span>
  <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="p">)</span>
   <span class="o">^</span>
</pre></table></code></div></div><p>它们的后缘维度相等， x 的第二维长度为 3 ，和 y 的维度相同。因此他们可以通过广播机制完成相加，在这个例子当中是将 y 沿着 0 轴进行扩展。</p><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/Harry-hhj/Harry-hhj.github.io/master/_posts/2021-10-14-Numpy-Tutorial.assets/v2-87f0be4142448c4b2ddbf519e478eac5_1440w.jpg" alt="img" /></p><p>同样，下图也是可以的。</p><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/Harry-hhj/Harry-hhj.github.io/master/_posts/2021-10-14-Numpy-Tutorial.assets/v2-658c89561ffa892d5f7935c0d1cd3dca_1440w.jpg" alt="img" /></p><h4 id="2-后缘维度不全相同有一方长度为1">2. 后缘维度不全相同，有一方长度为1</h4><div class="language-python highlighter-rouge"><div class="code-header"> <span text-data=" Python "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span> 
<span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">],[</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">]])</span>   
<span class="k">print</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span>
</pre></table></code></div></div><p>虽然 x 的 shape 为 $(4, 3)$ ， y 的 shape 为 $(4, 1)$ ，但第二个数组在 1 维轴上长度为 1 ，所以可以在 1 轴上进行广播。</p><div class="language-python highlighter-rouge"><div class="code-header"> <span text-data=" Python "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
 <span class="o">^</span> <span class="o">^</span>
<span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
 <span class="o">^</span> <span class="o">^</span>
</pre></table></code></div></div><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/Harry-hhj/Harry-hhj.github.io/master/_posts/2021-10-14-Numpy-Tutorial.assets/v2-a870a11727cc188a1749725228e372e0_1440w.jpg" alt="img" /></p><p>反例：</p><div class="language-python highlighter-rouge"><div class="code-header"> <span text-data=" Python "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span>
</pre></table></code></div></div><p>代码会报错无法计算，因为从后缘维度数起 2 轴上 x 、 y 大小即不相同也不为 1 。</p><p><br /></p><p>Numpy 中表示张量的数据类型是 <code class="language-plaintext highlighter-rouge">ndarray</code> 。我们先介绍 <code class="language-plaintext highlighter-rouge">ndarray</code> 对象的基本概念，理解这些概念对你以后了解张量运算和实现有非常大的帮助！</p><h3 id="1张量整体的属性">（1）张量整体的属性</h3><p>一个张量是由一个数据头和一个数据块指针组成的。数据头中存放了张量的属性值，包括数据类型、数组形状和每个维度的 <code class="language-plaintext highlighter-rouge">stride</code> 。数据块指针指向的是张量的数据值，<strong>对应内存中的一块连续的内存空间</strong>。</p><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/Harry-hhj/Harry-hhj.github.io/master/_posts/2021-10-14-Numpy-Tutorial.assets/Numpy.png" alt="Numpy" /></p><p>数据类型很容易理解，比如 <code class="language-plaintext highlighter-rouge">int</code> 、 <code class="language-plaintext highlighter-rouge">float</code> 、 <code class="language-plaintext highlighter-rouge">bool</code> ，这些值<strong>代表了多少个内存单元表示一个数据</strong>，例如 <code class="language-plaintext highlighter-rouge">int</code> 表示一个数据占用 4 个字节。</p><p><strong>数组形状表示张量的形状大小，它指定了张量的各个维度</strong>，例如 $(3,4,5)$ 表示一个 $3\times4\times5$ 的张量。我们规定：张量的最后一维称为低维，在低维上数据的内存分布是连续的，而第一个维称为高维。例如上面的例子中最高维是 $3$ 维，最低维是 $5$ 维。</p><p>每个维度的 stride 是为了方便数据的索引、存放和运算。 <strong>stride 表示在每一个维度上加一时需要越过多少个数据。</strong>它是通过公式计算得出的，你很快会发现计算过程非常简单。例如，对于 shape 等于 $(3, 4, 5)$ ，那么 stride 等于 $(20, 5, 1)$。记得，最低维的数据是连续的，所以最低维索引加一意味着只要前进一个数据就能得到下一个数据，对于更高维，索引加一意味着需要越过比它维度低的所有数据，也就是比它低维的乘积。下面有个直观的示例，在上图中，紫色数据块第 0 维索引加一，对应红色数据块，此时它需要越过第 0 维大小的数据块个数 5 。</p><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/Harry-hhj/Harry-hhj.github.io/master/_posts/2021-10-14-Numpy-Tutorial.assets/Numpy-example.png" alt="Numpy-example" /></p><p><strong>之后你也会发现通过改变张量的 shape 和 stride 可以直接实现运算而不需要改变数据内存块！</strong></p><h4 id="2张量中元素的属性">（2）张量中元素的属性</h4><p>一个元素的属性包括</p><ul><li>元素值<li>元素坐标</ul><p>想象一下，对于转置，我们不需要改变数据块，只需要把每个元素的坐标颠倒一下就可以了。</p><h4 id="3张量运算">（3）张量运算</h4><p>张量有三种运算的方式：</p><ul><li>返回 <code class="language-plaintext highlighter-rouge">view</code> ，即返回的是数据本身，修改返回值将导致原变量的值发生变化<li>返回 <code class="language-plaintext highlighter-rouge">copy</code> ，即返回的数据的拷贝，后续操作与原变量无关<li>原地运算，即直接修改数据本身，无返回值</ul><h2 id="三numpy-运算">三、Numpy 运算</h2><p>下面举的例子都建议你手动在命令行输一遍，我们也提供了 ipynb 教程：链接: https://pan.baidu.com/s/1MOTfMB7XB2eQ-aEwS4z8_g 提取码: twd3。</p><h3 id="1-ndarray-对象的创建">（1） <code class="language-plaintext highlighter-rouge">ndarray</code> 对象的创建</h3><p><code class="language-plaintext highlighter-rouge">np.array()</code> ：从 python 列表创建，显式指定每个元素的值。</p><p><code class="language-plaintext highlighter-rouge">np.empty()</code> ：只指定形状，不指定值。<strong>元素值随机。</strong></p><p><code class="language-plaintext highlighter-rouge">np.zeros()</code> ：只指定形状。元素值全 0 。</p><p><code class="language-plaintext highlighter-rouge">np.ones()</code> ：只指定形状。元素值全 1 。</p><p><code class="language-plaintext highlighter-rouge">np.eye()</code> ：创建<strong>二维</strong>张量，对角线为 1 ，其余为 0 。</p><p><code class="language-plaintext highlighter-rouge">np.random.randn()</code> ：只指定形状，<strong>非元组</strong>。元素值标准正态分布。</p><p><code class="language-plaintext highlighter-rouge">np.random.uniform()</code> ：指定形状和上下限。元素值均匀分布。<strong>闭区间。</strong></p><p><code class="language-plaintext highlighter-rouge">np.random.randint()</code> ：指定形状和上下限。元素值均匀分布，但只会取整数。前闭后开。</p><p><code class="language-plaintext highlighter-rouge">np.arange()</code> ：创建一维张量。指定起点终点步长，类似 <code class="language-plaintext highlighter-rouge">range</code> 。前闭后开。</p><p><code class="language-plaintext highlighter-rouge">np.linspace()</code> ：创建一维等差数列。指定起点终点数量。<strong>闭区间。</strong></p><p><code class="language-plaintext highlighter-rouge">np.concatenate()</code> ：在某个维度上拼接若干个张量。维度数不变。返回 <code class="language-plaintext highlighter-rouge">copy</code> 。<strong>除了拼接的维度外要求其它维度大小相等。</strong>特殊： <code class="language-plaintext highlighter-rouge">torch.cat</code> 。</p><ul><li>可以想象成对于索引进行分类讨论，在一些时候选择某一个张量选择值</ul><p><code class="language-plaintext highlighter-rouge">np.stack()</code> ：在某个维度上堆叠若干个张量。维度数增加。返回 <code class="language-plaintext highlighter-rouge">copy</code> 。<strong>要求所有维度大小相等。</strong></p><ul><li>除了第 0 维堆叠不破坏内存连续性外，其他都会破坏。</ul><p><code class="language-plaintext highlighter-rouge">np.meshgrid()</code>：创建网格张量，返回两个张量，分别代表网格的 x 轴和 y 轴。</p><ol><li><p>坐标矩阵其实有大量的重复—— $X$ 的每一行都一样， $Y$ 的每一列都一样。基于这种强烈的规律性， numpy 提供的 <code class="language-plaintext highlighter-rouge">numpy.meshgrid()</code> 函数可以让我们快速生成坐标矩阵 $X$ ，$Y$ 。</p><li><p>举例：</p><div class="language-python highlighter-rouge"><div class="code-header"> <span text-data=" Python "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]),</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
 <span class="k">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
 <span class="c1"># [[0,1,2],
</span> <span class="c1">#  [0,1,2]]
</span> <span class="k">print</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
 <span class="c1"># [[0,0,0],
</span> <span class="c1">#  [1,1,1]]
</span></pre></table></code></div></div><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/Harry-hhj/Harry-hhj.github.io/master/_posts/2021-10-14-Numpy-Tutorial.assets/70.png" style="zoom:60%;" /></p></ol><h4 id="2-ndarray-对象的常用操作">（2） <code class="language-plaintext highlighter-rouge">ndarray</code> 对象的常用操作</h4><p><code class="language-plaintext highlighter-rouge">shape</code> ：获取当前张量的维度信息（维数以及每一维的长度）。</p><p><code class="language-plaintext highlighter-rouge">reshape()</code> ：返回更改维度后的 <code class="language-plaintext highlighter-rouge">view</code> 。</p><ul><li>更改的方式是<strong>不破坏内存连续性</strong>，只要各维度大小的乘积与原来各维度大小的乘积相等即可。因此，可以想象只需要强行改变 shape ，然后根据 shape 重新计算 stride，就能实现这一功能。例如， <code class="language-plaintext highlighter-rouge">shape=(3,4,5)</code> ， <code class="language-plaintext highlighter-rouge">stride=(20, 5, 1)</code> 经过 <code class="language-plaintext highlighter-rouge">reshape(15, 4)</code> 后 <code class="language-plaintext highlighter-rouge">shape=(15, 4)</code> ， <code class="language-plaintext highlighter-rouge">stride=(4, 1)</code> ，原数据块不用改变。</ul><p><code class="language-plaintext highlighter-rouge">resize()</code> ：更改自己的维度，无返回值。</p><ul><li><strong>不破坏内存连续性</strong></ul><p><code class="language-plaintext highlighter-rouge">transpose()</code> ：返回更改维度顺序后的 <code class="language-plaintext highlighter-rouge">view</code> 。返回值内存不连续，但内存地址不变。特殊： <code class="language-plaintext highlighter-rouge">torch.permute</code> 。</p><ul><li>这个操作通过改变shape 、 stride 即可实现。例如 <code class="language-plaintext highlighter-rouge">shape=(3, 4, 5)</code> ， <code class="language-plaintext highlighter-rouge">stride=(20, 5, 1)</code> 经过 <code class="language-plaintext highlighter-rouge">transpose(2, 0, 1)</code> 后变成 <code class="language-plaintext highlighter-rouge">shape=(5, 3, 4)</code> ， <code class="language-plaintext highlighter-rouge">stride=(1, 20, 5)</code> 。<strong>即对 <code class="language-plaintext highlighter-rouge">stride</code> 也进行相同的 transpose ，而不是根据公式重新计算！</strong></ul><p><code class="language-plaintext highlighter-rouge">T</code> ： <code class="language-plaintext highlighter-rouge">transpose() </code> 的特殊情况，针对<strong>二维张量</strong>，返回 <code class="language-plaintext highlighter-rouge">view</code> 。</p><p><code class="language-plaintext highlighter-rouge">squeeze()</code> ：删除长度为 1 的维度，返回 <code class="language-plaintext highlighter-rouge">view</code> 。特殊： <code class="language-plaintext highlighter-rouge">torch.unsqueeze()</code> ：添加某个长度为 1 的维度，返回 <code class="language-plaintext highlighter-rouge">view</code> 。</p><p><code class="language-plaintext highlighter-rouge">view()</code> ：提供对内存区域不同的切割方式，来完成数据类型的转换，而无须要对数据进行额外的copy，来节约内存空间，返回 <code class="language-plaintext highlighter-rouge">view</code> 。转换的数据内存必须是连续分布的。特殊： <code class="language-plaintext highlighter-rouge">torch.view</code> 。</p><p><code class="language-plaintext highlighter-rouge">repeat()</code> ：将某个维度复制 n 次，每个元素复制（因此在某个维度上复制出的数据是聚在一起的），返回 <code class="language-plaintext highlighter-rouge">copy</code> 。特殊： <code class="language-plaintext highlighter-rouge">torch.repeat</code> 。特殊： <code class="language-plaintext highlighter-rouge">torch.expand</code> 。</p><p><code class="language-plaintext highlighter-rouge">tile()</code> ：相当于多个张量 <code class="language-plaintext highlighter-rouge">concatenate()</code> 在一起，但可以同时复制多个维度。</p><p><code class="language-plaintext highlighter-rouge">copy()</code> ：返回自身的 <code class="language-plaintext highlighter-rouge">copy</code> 。特殊： <code class="language-plaintext highlighter-rouge">torch.clone()</code> 。</p><p><code class="language-plaintext highlighter-rouge">astype()</code> ：更改元素数据类型，返回 <code class="language-plaintext highlighter-rouge">copy</code> 。</p><h4 id="3-ndarray-对象的索引维度索引和整体索引">（3） <code class="language-plaintext highlighter-rouge">ndarray</code> 对象的索引（维度索引和整体索引）</h4><p>切片索引：一次只能索引一个维度。返回 <code class="language-plaintext highlighter-rouge">view</code> 。支持原地修改。</p><ul><li>一个索引结构如下： <code class="language-plaintext highlighter-rouge">[start:end:step]</code> ，其中区间是左闭右开， <code class="language-plaintext highlighter-rouge">step</code> 表示一次跳过多少。这三个参数都可以参略，当 <code class="language-plaintext highlighter-rouge">start</code> 省略时，默认从第一个开始，即 <code class="language-plaintext highlighter-rouge">0</code> ，当 <code class="language-plaintext highlighter-rouge">end</code> 省略时，默认从直到最后一个（包括），当 <code class="language-plaintext highlighter-rouge">step</code> 省略时，默认步长为 <code class="language-plaintext highlighter-rouge">1</code> 。第一个 <code class="language-plaintext highlighter-rouge">:</code> 不能参略。注意对于大小 <code class="language-plaintext highlighter-rouge">(3, 4, 5)</code> ，索引 <code class="language-plaintext highlighter-rouge">[:, :4, :]</code> 和 <code class="language-plaintext highlighter-rouge">[:, :, :]</code> 不同。</ul><p>坐标（列表）索引：一次只能索引一个维度。返回 <code class="language-plaintext highlighter-rouge">copy</code> 。支持原地修改。</p><ul><li>举例，对一个 $3\times3\times3$ 的张量，在第二维度进行索引，并按照 <code class="language-plaintext highlighter-rouge">[2, 0]</code> 的顺序返回结果。</ul><p>布尔索引：一次索引整个张量。返回 <code class="language-plaintext highlighter-rouge">copy</code> 。支持原地修改。</p><ul><li>用一个相同大小的 <code class="language-plaintext highlighter-rouge">bool_</code> 型张量， <code class="language-plaintext highlighter-rouge">1</code> 表示保留该值， <code class="language-plaintext highlighter-rouge">0</code> 表示舍弃该值。返回一维张量，按照数据在内存中的排列顺序排列。</ul><p>区域索引：利用 <code class="language-plaintext highlighter-rouge">np.ix_</code> ，产生笛卡尔积的映射关系。返回 <code class="language-plaintext highlighter-rouge">copy</code> 。支持原地修改。</p><ul><li>举例，<code class="language-plaintext highlighter-rouge">[np.ix_([0,2], [2, 1])]</code> 提取的元素分别是 <code class="language-plaintext highlighter-rouge">(0, 2), (0, 1), (2, 2), (2, 1)</code> ，组成一个 $2\times2$ 的张量。</ul><h4 id="4-ndarray-对象的运算">（4） <code class="language-plaintext highlighter-rouge">ndarray</code> 对象的运算</h4><p><code class="language-plaintext highlighter-rouge">max()</code> ， <code class="language-plaintext highlighter-rouge">min()</code> ， <code class="language-plaintext highlighter-rouge">mean()</code> ：在某个维度/整个张量上计算最大值，最小值，平均值。</p><p><code class="language-plaintext highlighter-rouge">argmax()</code> ， <code class="language-plaintext highlighter-rouge">argmin()</code> ：在某个维度上计算最大值坐标，最小值坐标。</p><p><code class="language-plaintext highlighter-rouge">+-*/</code> ：对应元素计算。注意 <code class="language-plaintext highlighter-rouge">*</code> 表示对应元素相乘，因此两个输入张量大小必须相等。</p><p><code class="language-plaintext highlighter-rouge">dot()</code> 和 <code class="language-plaintext highlighter-rouge">@</code> ：针对二维张量，矩阵乘法。</p><p>指数对数三角函数等：每个元素计算。</p><p>大于小于等于比较运算：每个元素计算。返回布尔张量。</p><p><code class="language-plaintext highlighter-rouge">floor()</code> ， <code class="language-plaintext highlighter-rouge">ceil()</code> ， <code class="language-plaintext highlighter-rouge">round()</code> ：向下取整，向上取整，四舍五入。</p><p><code class="language-plaintext highlighter-rouge">where()</code> ：输入一个布尔张量和两个同形状的其他张量，根据布尔值选择两个张量中的值。即对于每个坐标，如果对应布尔值为 1 ，则选择第一个张量对应位置的值，否则选择第二个张量对应位置的值。</p><h4 id="5nplinalg-线性代数相关运算">（5）<code class="language-plaintext highlighter-rouge">np.linalg</code> 线性代数相关运算</h4><p><code class="language-plaintext highlighter-rouge">np.linalg.det()</code> ：求二维矩阵的行列式，输入多维时以最低两维对高维分别进行计算</p><p><code class="language-plaintext highlighter-rouge">np.linalg.inv()</code> ：求逆</p><p><code class="language-plaintext highlighter-rouge">np.linalg.eig()</code> ：求特征值特征向量</p><p><code class="language-plaintext highlighter-rouge">np.linalg.norm()</code> ：求范数</p><ul><li><p>范数是具有“长度”概念的函数。</p><li>L0 范数：向量中非 0 的元素的个数。( L0 范数很难优化求解)<li>L1 范数：向量中各个元素绝对值之和。L1 会趋向于产生少量的特征，而其他的特征都是 0 。<li>L2 范数：向量各元素的平方和然后求平方根。可以防止过拟合，提升模型的泛化能力。L2 会选择更多的特征，这些特征都会接近于 0 。</ul><h4 id="6文件-io">（6）文件 io</h4><p><code class="language-plaintext highlighter-rouge">np.save</code> 和 <code class="language-plaintext highlighter-rouge">np.load</code> ：用于保存和加载一个 <code class="language-plaintext highlighter-rouge">ndarray</code> 张量</p><p><code class="language-plaintext highlighter-rouge">np.savetxt</code> 和 <code class="language-plaintext highlighter-rouge">np.loadtxt</code> ：以 txt 格式保存和加载一个<strong>二维</strong> <code class="language-plaintext highlighter-rouge">ndarray</code> 张量，可以指定分隔符</p><p><code class="language-plaintext highlighter-rouge">np.savez</code> 和 <code class="language-plaintext highlighter-rouge">np.load</code> ：用于同时保存多个 <code class="language-plaintext highlighter-rouge">ndarray</code> 张量，输入字典键值对，读取出一个字典</p><h2 id="四可视化">四、可视化</h2><p>Matlab 是一个常用的数据分析和绘图软件，在 Python 我们也可以使用 <code class="language-plaintext highlighter-rouge">matplotlib</code> 库绘制图形。在进行可视化时，我们使用的是 <code class="language-plaintext highlighter-rouge">matplotlib.pyplot</code> 子库。</p><ol><li><code class="language-plaintext highlighter-rouge">plt.plot()</code> ：绘制折线图<li><code class="language-plaintext highlighter-rouge">plt.scatter()</code> ：绘制散点图<li><code class="language-plaintext highlighter-rouge">plt.bar()</code> ：绘制柱形图<li><code class="language-plaintext highlighter-rouge">plt.hist()</code> ：绘制柱形图的频率分布<li><code class="language-plaintext highlighter-rouge">plt.imshow()</code> ：绘制图像（RGB 格式，与 OpenCV 的 BGR 不同）<li><code class="language-plaintext highlighter-rouge">plt.matshow()</code> ：可视化数组（热力图）<li><code class="language-plaintext highlighter-rouge">plt.savefig()</code> ：保存最新绘制的一幅图，在 <code class="language-plaintext highlighter-rouge">plt.show()</code> 之前调用 <code class="language-plaintext highlighter-rouge">plt.savefig()</code> ；否则保存出去会是白纸一张。<li><code class="language-plaintext highlighter-rouge">plt.show()</code> ：显示绘制好的图像<li><code class="language-plaintext highlighter-rouge">plt.imsave()</code> ：保存绘制好的图像<li><code class="language-plaintext highlighter-rouge">seaborn</code> 库，对 <code class="language-plaintext highlighter-rouge">matplotlib</code> 的二次封装，提供更美观的可视化。</ol><p><br /></p><p>注意点：形状是参数列表（参数类型）还是以元组/列表（数据类型）表示、区间开闭、运算方式。</p><p><br /></p><p>讲了这么多，一定记住一点：<strong>在神经网络中，如果有可能不是用 for 循环，就不要使用 for 循环！</strong></p><h2 id="五课后作业">五、课后作业</h2><p>为了巩固我们刚才讲解的知识，提升代码的实战能力，请完成以下课后作业 Quiz ，我们提供了参考答案，但这并不是唯一的正确答案。在下面的链接中还有一道较难的机器视觉实战题，我们并不是为了考察机器视觉，所以给出了计算方式，请用 Numpy 运算实现。</p><p>百度网盘链接: <em><a href="https://pan.baidu.com/s/1OHNeqrErD8zIaBiRyR0lUw">https://pan.baidu.com/s/1OHNeqrErD8zIaBiRyR0lUw</a></em> 提取码: 60kf</p><p><br /></p><p><strong>如果觉得本教程不错或对您有用，请前往项目地址 <a href="https://raw.githubusercontent.com/Harry-hhj/Harry-hhj.github.io">https://raw.githubusercontent.com/Harry-hhj/Harry-hhj.github.io</a> 点击 Star :) ，这将是对我的肯定和鼓励，谢谢！</strong></p><p><br /></p><h2 id="六参考教程">六、参考教程</h2><ol><li><a href="https://blog.csdn.net/longzhiwen888/article/details/46604265">Python 被导入模块多次被加载的问题（基于python的import机制）</a><li><a href="https://zhuanlan.zhihu.com/p/402163854">Numpy学习——广播机制理解</a></ol><hr /><p>作者：Harry-hhj，Github主页：<a href="https://raw.githubusercontent.com/Harry-hhj">传送门</a></p><p>讲师：xinyang，Github主页：<a href="https://raw.githubusercontent.com/xinyang-go">传送门</a></p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/course/'>Course</a>, <a href='/categories/nerual-network/'>Nerual Network</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/getting-started/" class="post-tag no-text-decoration" >getting started</a> <a href="/tags/robomaster/" class="post-tag no-text-decoration" >robomaster</a> <a href="/tags/numpy/" class="post-tag no-text-decoration" >numpy</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=神经网络集训 —— Numpy 的使用 - Harry's Blog&url=https://harry-hhj.github.io/posts/Numpy-Tutorial/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=神经网络集训 —— Numpy 的使用 - Harry's Blog&u=https://harry-hhj.github.io/posts/Numpy-Tutorial/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=神经网络集训 —— Numpy 的使用 - Harry's Blog&url=https://harry-hhj.github.io/posts/Numpy-Tutorial/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/RM-Tutorial-5-Monocular-Vision/">RM 教程 5 —— 单目视觉</a><li><a href="/posts/RM-Tutorial-Catalogue/">RoboMaster 课程目录</a><li><a href="/posts/NN-Tutorial-Catalogue/">神经网络课程目录</a><li><a href="/posts/RM-Tutorial-3-Getting-Started-with-OpenCV/">RM 教程 3 —— OpenCV 传统视觉</a><li><a href="/posts/RM-Tutorial-4-Camera/">RM 教程 4 —— 相机</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/getting-started/">getting started</a> <a class="post-tag" href="/tags/install/">install</a> <a class="post-tag" href="/tags/robomaster/">robomaster</a> <a class="post-tag" href="/tags/computer-science/">computer science</a> <a class="post-tag" href="/tags/tools/">tools</a> <a class="post-tag" href="/tags/catalog/">catalog</a> <a class="post-tag" href="/tags/opencv/">opencv</a> <a class="post-tag" href="/tags/pytorch/">pytorch</a> <a class="post-tag" href="/tags/c-c/">c/c++</a> <a class="post-tag" href="/tags/camera/">camera</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/RM-Tutorial-1-Linux-Introduction/"><div class="card-body"> <span class="timeago small" >Sep 24<i class="unloaded">2021-09-24T16:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>RM 教程 1 —— Linux 教程</h3><div class="text-muted small"><p> RM 教程 1 —— Linux 教程 机械是血肉，电控是大脑，视觉是灵魂。 一、Why Linux &amp; Why Ubuntu Ubuntu 是一个十分流行并且好用的 Linux 桌面发行版本。截止到目前，Ubuntu 已经发行了 Ubuntu 20.04 的版本，并且其稳定性和支持已经很不错了。你可以在这里下载各个版本的 Ubuntu 系统镜像文件，虚拟机的话一般...</p></div></div></a></div><div class="card"> <a href="/posts/RM-Tutorial-2-Install-OpenCV/"><div class="card-body"> <span class="timeago small" >Oct 2<i class="unloaded">2021-10-02T13:30:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>RM 教程 2 —— 安装 OpenCV</h3><div class="text-muted small"><p> RM 教程 2 —— 安装 OpenCV 机械是血肉，电控是大脑，视觉是灵魂。 一、简介 OpenCV 是计算机视觉中经典的专用库，其支持多语言，跨平台，功能强大。 opencv-python 为OpenCV 提供了 Python 接口，使得使用者在 Python 中能够调用 C/C++ ，在保证易读性和运行效率的前提下，实现所需的功能。 OpenCV 现在支持与计算机视...</p></div></div></a></div><div class="card"> <a href="/posts/RM-Tutorial-3-Getting-Started-with-OpenCV/"><div class="card-body"> <span class="timeago small" >Oct 2<i class="unloaded">2021-10-02T18:05:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>RM 教程 3 —— OpenCV 传统视觉</h3><div class="text-muted small"><p> RM 教程 3 —— OpenCV 传统视觉 机械是血肉，电控是大脑，视觉是灵魂。 本片教程主要集中于边缘及轮廓检测。 一、OpenCV 基本组件 - Mat Mat 是 OpenCV 中常用的基本类型，即矩阵类。在计算机内存中，数字图像以矩阵的形式存储和运算，因此 OpenCV 中常常用 Mat 储存图像数据。 Mat 本质上由两个数据部分组成：矩阵头和一个指向像素数...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/NN-Tutorial-Catalogue/" class="btn btn-outline-primary" prompt="Older"><p>神经网络课程目录</p></a> <a href="/posts/RM-Tutorial-5-Monocular-Vision/" class="btn btn-outline-primary" prompt="Newer"><p>RM 教程 5 —— 单目视觉</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2021 <a href="https://github.com/Harry-hhj">HHJ</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/getting-started/">getting started</a> <a class="post-tag" href="/tags/install/">install</a> <a class="post-tag" href="/tags/robomaster/">robomaster</a> <a class="post-tag" href="/tags/computer-science/">computer science</a> <a class="post-tag" href="/tags/tools/">tools</a> <a class="post-tag" href="/tags/catalog/">catalog</a> <a class="post-tag" href="/tags/opencv/">opencv</a> <a class="post-tag" href="/tags/pytorch/">pytorch</a> <a class="post-tag" href="/tags/c-c/">c/c++</a> <a class="post-tag" href="/tags/camera/">camera</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script> /* see: <https://docs.mathjax.org/en/latest/options/input/tex.html#tex-options> */ MathJax = { tex: { inlineMath: [ /* start/end delimiter pairs for in-line math */ ['$','$'], ['\\(','\\)'] ], displayMath: [ /* start/end delimiter pairs for display math */ ['$$', '$$'], ['\\[', '\\]'] ] } }; </script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"> </script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script>

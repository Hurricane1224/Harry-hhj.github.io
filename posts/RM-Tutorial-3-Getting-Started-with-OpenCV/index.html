<!DOCTYPE html><html lang="zh" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content="days ago"><meta name="hour-prompt" content="hours ago"><meta name="minute-prompt" content="minutes ago"><meta name="justnow-prompt" content="just now"><meta name="generator" content="Jekyll v4.2.1" /><meta property="og:title" content="RM 教程 3 —— OpenCV 传统视觉" /><meta name="author" content="Harry-hhj" /><meta property="og:locale" content="zh" /><meta name="description" content="RM 教程 3 —— OpenCV 传统视觉" /><meta property="og:description" content="RM 教程 3 —— OpenCV 传统视觉" /><link rel="canonical" href="https://harry-hhj.github.io/posts/RM-Tutorial-3-Getting-Started-with-OpenCV/" /><meta property="og:url" content="https://harry-hhj.github.io/posts/RM-Tutorial-3-Getting-Started-with-OpenCV/" /><meta property="og:site_name" content="Harry’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-10-02T18:05:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="RM 教程 3 —— OpenCV 传统视觉" /><meta name="twitter:site" content="@None" /><meta name="twitter:creator" content="@Harry-hhj" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"author":{"@type":"Person","name":"Harry-hhj"},"description":"RM 教程 3 —— OpenCV 传统视觉","url":"https://harry-hhj.github.io/posts/RM-Tutorial-3-Getting-Started-with-OpenCV/","@type":"BlogPosting","headline":"RM 教程 3 —— OpenCV 传统视觉","dateModified":"2021-11-04T18:50:30+08:00","datePublished":"2021-10-02T18:05:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://harry-hhj.github.io/posts/RM-Tutorial-3-Getting-Started-with-OpenCV/"},"@context":"https://schema.org"}</script><title>RM 教程 3 —— OpenCV 传统视觉 | Harry's Blog</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Harry's Blog"><meta name="application-name" content="Harry's Blog"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script> var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?f40851b91841f1abe810a63f8d41c2e2"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })(); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end" lang="en"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/avatar/avatar.jpeg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Harry's Blog</a></div><div class="site-subtitle font-italic">Write blogs, share ideas, make friends and enjoy life.</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <a href="https://github.com/Harry-hhj" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['Harry_hhj','163.com'].join('@')" aria-label="email" class="order-4" > <i class="fas fa-envelope"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>RM 教程 3 —— OpenCV 传统视觉</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>RM 教程 3 —— OpenCV 传统视觉</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Harry-hhj </span> on <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Sat, Oct 2, 2021, 6:05 PM +0800" >Oct 2<i class="unloaded">2021-10-02T18:05:00+08:00</i> </span></div><div> <span> Updated <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Thu, Nov 4, 2021, 6:50 PM +0800" >Nov 4<i class="unloaded">2021-11-04T18:50:30+08:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="11436 words">63 min read</span></div></div><div class="post-content"> <img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 639 639'%3E%3C/svg%3E" data-proofer-ignore data-src="https://raw.githubusercontent.com/Harry-hhj/Harry-hhj.github.io/master/_posts/2021-10-02-RM-Tutorial-3-Getting-Started-with-OpenCV.assets/IMG_4633.JPG" class="preview-img" alt="Preview Image" width="639" height="639"><h1 id="rm-教程-3--opencv-传统视觉">RM 教程 3 —— OpenCV 传统视觉</h1><blockquote><p>机械是血肉，电控是大脑，视觉是灵魂。</p></blockquote><hr /><p>本片教程主要集中于边缘及轮廓检测。</p><h2 id="一opencv-基本组件---mat">一、OpenCV 基本组件 - Mat</h2><p><code class="language-plaintext highlighter-rouge">Mat</code> 是 OpenCV 中常用的基本类型，即矩阵类。在计算机内存中，数字图像以矩阵的形式存储和运算，因此 OpenCV 中常常用 <code class="language-plaintext highlighter-rouge">Mat</code> 储存图像数据。</p><p><strong><code class="language-plaintext highlighter-rouge">Mat</code> 本质上由两个数据部分组成：矩阵头和一个指向像素数据的指针。</strong>矩阵头部的大小是恒定的。然而，矩阵本身的大小因图像的不同而不同。这一数据结构的好处是： <code class="language-plaintext highlighter-rouge">Mat</code> 的每个对象具有其自己的头，但可通过矩阵指针指向同一地址让两个实例之间共享该矩阵。<strong>除非你明确指明需要复制数据，不然 Mat 只会复制矩阵头部，并将数据指针指向同一地址，而不会复制矩阵本身。</strong></p><h3 id="1构造函数">1）构造函数</h3><p><code class="language-plaintext highlighter-rouge">Mat</code> 常用的构造方式有两种：</p><ul><li><code class="language-plaintext highlighter-rouge">Mat()</code> ：这种 <code class="language-plaintext highlighter-rouge">Mat</code> 由于未定义维度和大小，无法直接使用，一般用来接收函数的输出，被重新赋值<li><code class="language-plaintext highlighter-rouge">Mat (int rows, int cols, int type)</code> ：创建一个行数为 <code class="language-plaintext highlighter-rouge">rows</code> ，列数为 <code class="language-plaintext highlighter-rouge">cols</code> ，数据类型为 <code class="language-plaintext highlighter-rouge">type</code> 的矩阵。<ul><li><code class="language-plaintext highlighter-rouge">type</code> ：<strong><code class="language-plaintext highlighter-rouge">CV_[位数][有无符号][数据类型][通道数]</code></strong> ，对于图片值一般为 <code class="language-plaintext highlighter-rouge">CV_8UC3</code> ，其中 <code class="language-plaintext highlighter-rouge">8U</code> 代表 8 位无符号整数， <code class="language-plaintext highlighter-rouge">C3</code> 代表 3 通道，这是一般用来储存 3 通道图像的格式。当然 <code class="language-plaintext highlighter-rouge">type</code> 还有很多其他类型，例如 <code class="language-plaintext highlighter-rouge">CV_64FC1</code> 表示一般的实数矩阵。</ul></ul><h3 id="2初始化">2）初始化</h3><p>初始化一个矩阵有两种方式：等号赋值或 <code class="language-plaintext highlighter-rouge">create()</code> 成员函数 。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span text-data=" C++ "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">src</span> <span class="o">=</span> <span class="n">imread</span><span class="p">(</span><span class="s">"logo.png"</span><span class="p">);</span>

<span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">src</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">src</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">src</span><span class="p">.</span><span class="n">create</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">CV_8UC3</span><span class="p">);</span>  <span class="c1">// 这种方法创建的内存空间一定是连续的</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="3成员变量和函数">3）成员变量和函数</h3><p>比较常用的获取矩阵信息的变量和函数有：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span text-data=" C++ "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="nf">src1</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">CV_8UC3</span><span class="p">);</span>

<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">src1</span><span class="p">.</span><span class="n">cols</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>  <span class="c1">// 图片行数：3</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">src1</span><span class="p">.</span><span class="n">rows</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>  <span class="c1">// 图片列数：3</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">src1</span><span class="p">.</span><span class="n">channels</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>  <span class="c1">// 图片通道数，注意是成员函数：3</span>
</pre></table></code></div></div><h3 id="4拷贝">4）拷贝</h3><p>通过下面这个例子，你会很容易理解为什么当我们想复制数据时必须显示指明：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span text-data=" C++ "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="nf">src2</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">CV_8UC3</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Pointer src2.data points to"</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">src2</span><span class="p">.</span><span class="n">data</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">src2_copy1</span> <span class="o">=</span> <span class="n">src2</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Pointer src2_copy1.data points to"</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">src2_copy1</span><span class="p">.</span><span class="n">data</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">src2_copy2</span> <span class="o">=</span> <span class="n">src2</span><span class="p">.</span><span class="n">clone</span><span class="p">();</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Pointer src2_copy2.data points to"</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">src2_copy2</span><span class="p">.</span><span class="n">data</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</pre></table></code></div></div><p>程序运行结果：</p><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/Harry-hhj/Harry-hhj.github.io/master/_posts/2021-10-02-RM-Tutorial-3-Getting-Started-with-OpenCV.assets/image-20211003110640589.png" alt="image-20211003110640589" /></p><p>可以看到通过等号赋值的 <code class="language-plaintext highlighter-rouge">src2_copy1</code> 的指针与 <code class="language-plaintext highlighter-rouge">src2</code> 指向同一片内存地址，这意味着对任意一个变量的操作会影响另一个，而通过使用 <code class="language-plaintext highlighter-rouge">clone()</code> ，系统为新的变量 <code class="language-plaintext highlighter-rouge">src_copy2</code> 创建了一块新的内存空间，并把原始变量拷贝了过去。</p><p>除了 <code class="language-plaintext highlighter-rouge">clone()</code> 外，成员函数 <code class="language-plaintext highlighter-rouge">copyto(cv::Mat dst)</code> 也有相同的效果。</p><p>TODO：refcount</p><h3 id="5格式化输出">5）格式化输出</h3><p>使用 <code class="language-plaintext highlighter-rouge">std::cout</code> 来格式化输出 <code class="language-plaintext highlighter-rouge">Mat</code> 类型的变量，仅限于二维的。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span text-data=" C++ "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">src3</span> <span class="o">=</span> <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="o">::</span><span class="n">zeros</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">CV_64F</span><span class="p">);</span>
<span class="c1">// 默认格式</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">src3</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="c1">// python 格式</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">cv</span><span class="o">::</span><span class="n">format</span><span class="p">(</span><span class="n">src3</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">Formatter</span><span class="o">::</span><span class="n">FMT_PYTHON</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="c1">// C 格式</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">cv</span><span class="o">::</span><span class="n">format</span><span class="p">(</span><span class="n">src3</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">Formatter</span><span class="o">::</span><span class="n">FMT_C</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="c1">// numpy 格式</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">cv</span><span class="o">::</span><span class="n">format</span><span class="p">(</span><span class="n">src3</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">Formatter</span><span class="o">::</span><span class="n">FMT_NUMPY</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</pre></table></code></div></div><p>输出结果如下：</p><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/Harry-hhj/Harry-hhj.github.io/master/_posts/2021-10-02-RM-Tutorial-3-Getting-Started-with-OpenCV.assets/image-20211003122207307.png" alt="image-20211003122207307" style="zoom:50%;" /></p><h3 id="6矩阵的随机访问">6）矩阵的随机访问</h3><p>Mat 类型本身没有实现 [] 的随机访问，因此如果想要随机访问矩阵中的元素，需要其他方法。</p><ul><li><p><code class="language-plaintext highlighter-rouge">Mat</code> 提供了 <code class="language-plaintext highlighter-rouge">at</code> 方法，其声明如下：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span text-data=" C++ "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">_Tp</span> <span class="p">&gt;</span>
<span class="n">_Tp</span><span class="o">&amp;</span> <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="o">::</span><span class="n">at</span><span class="p">(</span><span class="kt">int</span> <span class="n">row</span><span class="p">,</span> <span class="kt">int</span> <span class="n">col</span><span class="p">)</span>
</pre></table></code></div></div><p>通过 <code class="language-plaintext highlighter-rouge">at</code> 方法，可以随机访问 row 行 col 列的元素，下面是一个简单的例子：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span text-data=" C++ "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">src4</span> <span class="o">=</span> <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="o">::</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">CV_8UC1</span><span class="p">);</span>
<span class="n">src4</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">src4</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</pre></table></code></div></div><p>从结果可以看出，第 1 行 1 列的元素从 $1$ 变成了 $2$ ：</p><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/Harry-hhj/Harry-hhj.github.io/master/_posts/2021-10-02-RM-Tutorial-3-Getting-Started-with-OpenCV.assets/image-20211003124637243.png" alt="image-20211003124637243" style="zoom:50%;" /></p><li><p><code class="language-plaintext highlighter-rouge">Mat</code> 类提供的 <code class="language-plaintext highlighter-rouge">ptr</code> 方法也可以借助指针的方式实现随机访问，其声明如下：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span text-data=" C++ "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre> <span class="n">uchar</span><span class="o">*</span> <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="o">::</span><span class="n">ptr</span><span class="p">(</span><span class="kt">int</span> <span class="n">i0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
</pre></table></code></div></div><p>通过 <code class="language-plaintext highlighter-rouge">ptr</code> 方法，可以返回矩阵第 <code class="language-plaintext highlighter-rouge">i0</code> 行的指针，通过指针进一步访问矩阵的元素，下面是一个 简单的例子：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span text-data=" C++ "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">src5</span> <span class="o">=</span> <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="o">::</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">CV_8UC1</span><span class="p">);</span>
<span class="n">uchar</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">src5</span><span class="p">.</span><span class="n">ptr</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="n">ptr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">src5</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</pre></table></code></div></div><p>从结果可以看出，该代码达到了和 <code class="language-plaintext highlighter-rouge">at()</code> 一样的效果：</p><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/Harry-hhj/Harry-hhj.github.io/master/_posts/2021-10-02-RM-Tutorial-3-Getting-Started-with-OpenCV.assets/image-20211003125310421.png" alt="image-20211003125310421" style="zoom:50%;" /></p></ul><h3 id="7mat-简单运算">7）Mat 简单运算</h3><ul><li><p>复制 <code class="language-plaintext highlighter-rouge">clone()</code></p><p>为什么要使用 <code class="language-plaintext highlighter-rouge">clone()</code> 而不能使用 <code class="language-plaintext highlighter-rouge">=</code> 在上面已经讲过了，这里举个例子让读者直观感受两种操作的不同：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span text-data=" C++ "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">src6</span> <span class="o">=</span> <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="o">::</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">CV_8UC1</span><span class="p">);</span>
<span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">src6_copy1</span> <span class="o">=</span> <span class="n">src6</span><span class="p">;</span>
<span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">src6_copy2</span> <span class="o">=</span> <span class="n">src6</span><span class="p">.</span><span class="n">clone</span><span class="p">();</span>
<span class="n">src6</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"src6_copy1:</span><span class="se">\n</span><span class="s">"</span> <span class="o">&lt;&lt;</span> <span class="n">src6_copy1</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"src6_copy2:</span><span class="se">\n</span><span class="s">"</span> <span class="o">&lt;&lt;</span> <span class="n">src6_copy2</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</pre></table></code></div></div><p>结果是 <code class="language-plaintext highlighter-rouge">=</code> 复制的矩阵 <code class="language-plaintext highlighter-rouge">src6_copy1</code> 被同时修改，而通过 <code class="language-plaintext highlighter-rouge">clone()</code> 复制的 <code class="language-plaintext highlighter-rouge">src6_copy2</code> 没有变化：</p><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/Harry-hhj/Harry-hhj.github.io/master/_posts/2021-10-02-RM-Tutorial-3-Getting-Started-with-OpenCV.assets/image-20211003130209801.png" alt="image-20211003130209801" style="zoom:50%;" /></p><p><strong>如果想要安全地复制，使用 OpenCV 提供的矩阵复制函数。</strong></p><li><p><code class="language-plaintext highlighter-rouge">+</code> 、 <code class="language-plaintext highlighter-rouge">-</code> 、 <code class="language-plaintext highlighter-rouge">*</code></p><ul><li><p><code class="language-plaintext highlighter-rouge">+</code></p><p>OpenCV中重载了矩阵的 + 运算符，同时有 <code class="language-plaintext highlighter-rouge">virtual void cv::MatOp::add(const MatExpr &amp;expr1, const MatExpr &amp;expr2, MatExpr &amp;res)</code> 方法实现了加法运算。</p><li><p><code class="language-plaintext highlighter-rouge">-</code></p><p>OpenCV中重载了矩阵的 - 运算符，同时有 <code class="language-plaintext highlighter-rouge">virtual void cv::MatOp::subtract(const MatExpr &amp;expr1, const MatExpr &amp;expr2, MatExpr &amp;res)</code> 方法实现了减法运算。</p><li><p><code class="language-plaintext highlighter-rouge">*</code></p><p>OpenCV中重载了矩阵的 * 运算符，对应矩阵乘法。而 <code class="language-plaintext highlighter-rouge">void cv::multiply(const MatExpr &amp;expr1, const MatExpr &amp;expr2, MatExpr &amp;res)</code> 函数<strong>实现的是矩阵的对应位数据相乘，而不是矩阵乘法</strong>。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span text-data=" C++ "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">src7</span> <span class="o">=</span> <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="o">::</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">CV_64FC1</span><span class="p">);</span>
<span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">src8</span> <span class="o">=</span> <span class="p">(</span><span class="n">cv</span><span class="o">::</span><span class="n">Mat_</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"src7 * src8 = </span><span class="se">\n</span><span class="s">"</span> <span class="o">&lt;&lt;</span> <span class="n">src7</span> <span class="o">*</span> <span class="n">src8</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">res</span><span class="p">;</span>
<span class="n">cv</span><span class="o">::</span><span class="n">multiply</span><span class="p">(</span><span class="n">src7</span><span class="p">,</span> <span class="n">src8</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"cv::multiply(src7, src8, res) = </span><span class="se">\n</span><span class="s">"</span> <span class="o">&lt;&lt;</span> <span class="n">res</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</pre></table></code></div></div><p>最终两种运算的结果是不同的：</p><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/Harry-hhj/Harry-hhj.github.io/master/_posts/2021-10-02-RM-Tutorial-3-Getting-Started-with-OpenCV.assets/image-20211003154548150.png" alt="image-20211003154548150" style="zoom:50%;" /></p></ul></ul><h3 id="8读写图片和视频">8）读写图片和视频</h3><p>OpenCV 中提供了函数 <code class="language-plaintext highlighter-rouge">Mat cv::imread(const String &amp;filename, int flags = IMREAD_COLOR)</code> 实现从指定文件中读取图片，通过函数 <code class="language-plaintext highlighter-rouge">cv::imwrite(const String &amp;location, const cv::Mat &amp;src)</code> 实现。</p><p>OpenCV 中提供了 <code class="language-plaintext highlighter-rouge">VideoCapture</code> 类完成读取视频的工作。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span text-data=" C++ "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="n">cv</span><span class="o">::</span><span class="n">VideoCapture</span> <span class="nf">cap</span><span class="p">(</span><span class="n">PROJECT_DIR</span><span class="s">"/assets/test.avi"</span><span class="p">);</span>
<span class="n">assert</span><span class="p">(</span><span class="n">cap</span><span class="p">.</span><span class="n">isOpened</span><span class="p">());</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">cap</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">cv</span><span class="o">::</span><span class="n">CAP_PROP_FRAME_HEIGHT</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">cap</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">cv</span><span class="o">::</span><span class="n">CAP_PROP_FRAME_WIDTH</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="n">cv</span><span class="o">::</span><span class="n">VideoWriter</span> <span class="nf">writer</span><span class="p">(</span><span class="n">PROJECT_DIR</span><span class="s">"/assets/test_copy.avi"</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">VideoWriter</span><span class="o">::</span><span class="n">fourcc</span><span class="p">(</span><span class="sc">'M'</span><span class="p">,</span> <span class="sc">'J'</span><span class="p">,</span> <span class="sc">'P'</span><span class="p">,</span> <span class="sc">'G'</span><span class="p">),</span> <span class="mi">10</span><span class="p">,</span> <span class="p">{(</span><span class="kt">int</span><span class="p">)</span><span class="n">cap</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">cv</span><span class="o">::</span><span class="n">CAP_PROP_FRAME_WIDTH</span><span class="p">),</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">cap</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">cv</span><span class="o">::</span><span class="n">CAP_PROP_FRAME_HEIGHT</span><span class="p">)},</span> <span class="nb">true</span><span class="p">);</span>
<span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">src10</span><span class="p">;</span>
<span class="n">cv</span><span class="o">::</span><span class="n">namedWindow</span><span class="p">(</span><span class="s">"video"</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"press q to exit."</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="n">cap</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="n">src10</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">cv</span><span class="o">::</span><span class="n">imshow</span><span class="p">(</span><span class="s">"video"</span><span class="p">,</span> <span class="n">src10</span><span class="p">);</span>
    <span class="n">writer</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">src10</span><span class="p">);</span>
    <span class="c1">// writer &lt;&lt; src10;</span>
    <span class="kt">char</span> <span class="n">k</span> <span class="o">=</span> <span class="n">cv</span><span class="o">::</span><span class="n">waitKey</span><span class="p">(</span><span class="mi">200</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">==</span> <span class="sc">'q'</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">cv</span><span class="o">::</span><span class="n">destroyWindow</span><span class="p">(</span><span class="s">"video"</span><span class="p">);</span>
<span class="n">cap</span><span class="p">.</span><span class="n">release</span><span class="p">();</span>
<span class="n">writer</span><span class="p">.</span><span class="n">release</span><span class="p">();</span>
</pre></table></code></div></div><h2 id="二为什么要做边缘检测">二、为什么要做边缘检测</h2><p>大多数图像处理软件的最终目的都是识别与分割。识别即“是什么”，分割即“在哪里”。而为了将目标物体从图片中分割出来，如果这个物体有着鲜明的特征，使得目标物体和背景有着极大的区分度（如黑暗中的亮点，大面积的色块），我们就可以比较容易的将这个物体提取出来。</p><p>因为现在的目标物体和背景有着极大的区分度，也就意味着<strong>目标和背景有着明显的“分界线”，也就是边缘</strong>；而<strong>多个连续的边缘点，就构成了这个物体的轮廓</strong>。所以我们可以将检测物体这个任务，转换为检测物体和背景的分界线，也就是边缘检测。</p><h2 id="三如何进行边缘检测">三、如何进行边缘检测</h2><p>在进行边缘检测之前，我们首先需要明确，我们想对图像中的哪种信息进行边缘检测。一般来讲，我们会<strong>对图像的亮度信息进行边缘检测</strong>，也就是在单色灰度图上检测边缘，此时检测到的边缘点是亮度变化较大的点。但有的时候，目标和背景的亮度差异不大，没法通过亮度边缘确定目标和背景的分界线；但目标和背景的颜色差异可能很大，这时就会<strong>对图像的颜色信息进行边缘检测</strong>，此时检测到的边缘点就是颜色变化最大的点。</p><p>在确定了我们想检测怎样的边缘后，我们就需要一个方法把边缘给找出来。下面介绍几个常用的方法（假设我们现在是要检测亮度边缘）</p><p>为了进行对一个图片的亮度进行判断，我们需要把一个 RGB 图片转成灰度图片，转换后越亮的像素点越接近白色（255），而越暗的像素点越接近黑色（0），图像由三通道变为单通道。其原理是：RGB 值和灰度的转换，实际上是人眼对于彩色的感觉到亮度感觉的转换，这是一个心理学问题，有一个公式： \(Grey = 0.299*R + 0.587*G + 0.114*B\) <strong>可以通过将浮点数运算转化为整数运算，整数运算转换为位操作进行优化</strong>。</p><p>在 OpenCV 中，提供了 <code class="language-plaintext highlighter-rouge">cv::cvtColor()</code> 函数完成各种颜色空间的转换：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span text-data=" C++ "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="n">cv</span><span class="o">::</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">cv</span><span class="o">::</span><span class="n">InputArray</span> <span class="n">src</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">OutputArray</span> <span class="n">dst</span><span class="p">,</span> <span class="kt">int</span> <span class="n">code</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dstCn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>  
</pre></table></code></div></div><p>例如对于下面这张图片：</p><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/Harry-hhj/Harry-hhj.github.io/master/_posts/2021-10-02-RM-Tutorial-3-Getting-Started-with-OpenCV.assets/apple.jpg" alt="apple" /></p><p>我们通过以下代码将其转化为灰度图：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span text-data=" C++ "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">img</span> <span class="o">=</span> <span class="n">cv</span><span class="o">::</span><span class="n">imread</span><span class="p">(</span><span class="n">PROJECT_DIR</span><span class="s">"/assets/apple.jpg"</span><span class="p">);</span>
<span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">gray</span><span class="p">;</span>
<span class="n">cv</span><span class="o">::</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">gray</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">COLOR_BGR2GRAY</span><span class="p">);</span>
<span class="n">cv</span><span class="o">::</span><span class="n">imshow</span><span class="p">(</span><span class="s">"gray"</span><span class="p">,</span> <span class="n">gray</span><span class="p">);</span>
<span class="n">cv</span><span class="o">::</span><span class="n">waitKey</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</pre></table></code></div></div><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/Harry-hhj/Harry-hhj.github.io/master/_posts/2021-10-02-RM-Tutorial-3-Getting-Started-with-OpenCV.assets/apple_grey.jpg" alt="apple_grey" /></p><p>有另一种方法是在读如图片时指定读取灰度图，但是由于其实用性较低，不与赘述。</p><h3 id="1二值化">1）二值化</h3><p>由于目标和背景的亮度差异很大，那么最简单的想法就是设定一个阈值，亮度高于该阈值的像素设为目标，亮度低于该阈值的像素设为背景。而这两片区域的交界处便是边缘。</p><p>再特殊一点：目标的亮度不一定就是很高，或者很低，而是在一个范围内（如100~150），此时我们的二值化就和上面有一定的区别，将这两个阈值范围内的像素设为目标，不在该范围内的设为边缘。</p><p>更进一步：二值化指的是一个函数 <code class="language-plaintext highlighter-rouge">f(x)</code> ，其自变量是某个像素的亮度值，其因变量（或者说函数的输出）是 $255$ 或 $0$ ，分别代表目标和背景。</p><p>在 OpenCV 中，对应实现这一功能的函数是：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span text-data=" C++ "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">double</span> <span class="n">cv</span><span class="o">::</span><span class="n">threshold</span><span class="p">(</span><span class="n">InputArray</span> <span class="n">src</span><span class="p">,</span> <span class="n">OutputArray</span> <span class="n">dst</span><span class="p">,</span> <span class="kt">double</span> <span class="n">thresh</span><span class="p">,</span> <span class="kt">double</span> <span class="n">maxval</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">)</span>
</pre></table></code></div></div><p>参数：</p><ul><li><p><code class="language-plaintext highlighter-rouge">src</code>：输入</p><li><p><code class="language-plaintext highlighter-rouge">dst</code>：输出</p><li><p><code class="language-plaintext highlighter-rouge">thres</code>：设定的二值化阈值</p><li><p><code class="language-plaintext highlighter-rouge">maxval</code>：使用 THRESH_BINARY 或 THRESH_BINARY_INV 进行二值化时使用的最大值</p><li><p><code class="language-plaintext highlighter-rouge">type</code>：二值化算法类型</p><ul><li><code class="language-plaintext highlighter-rouge">THRESH_BINARY</code>：将小于 thres 的值变为 0 ，大于 thres 的值变为 255<li><code class="language-plaintext highlighter-rouge">THRESH_BINARY_INV</code>：将小于 thres 的值变为 255, 大于 thres 的值变为 0<li><code class="language-plaintext highlighter-rouge">THRESH_TRUNC</code>：将大于 thres 的值截取为 thres, 小于 thres 的值不变<li><code class="language-plaintext highlighter-rouge">THRESH_TOZERO</code>：将小于 thres 的值变为 0 , 大于 thres 的值不变<li><code class="language-plaintext highlighter-rouge">THRESH_TOZERO_INV</code>：将大于 thres 的值变为 0 , 小于 thres 的值不变</ul><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/Harry-hhj/Harry-hhj.github.io/master/_posts/2021-10-02-RM-Tutorial-3-Getting-Started-with-OpenCV.assets/image-20211004105640441.png" alt="image-20211004105640441" style="zoom:30%;" /></p></ul><p>举个例子，现在我们需要将这样一种图进行二值化，提取其中棋盘格黑色的区域：</p><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/Harry-hhj/Harry-hhj.github.io/master/_posts/2021-10-02-RM-Tutorial-3-Getting-Started-with-OpenCV.assets/calibrate.jpg" alt="calibrate" /></p><p>我们用下面这段程序实现了这一功能：</p><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/Harry-hhj/Harry-hhj.github.io/master/_posts/2021-10-02-RM-Tutorial-3-Getting-Started-with-OpenCV.assets/thres.jpg" alt="thres" /></p><p>可以看到我们很好地提取出了黑色的部分。</p><h3 id="2-自适应二值化">2） 自适应二值化</h3><h4 id="1-全局自适应">1. 全局自适应</h4><p>由于图片的亮度很容易受到环境的影响，比如环境亮度不同，相机曝光不同等因素都可能影响到最终成像出来的图片的亮度。这样，原本在较亮环境下设定的 180 的亮度阈值可以较好和分割出目标，到了较暗环境下效果就变差，甚至完全不起作用了。</p><p>但是环境对成像图片亮度的影响是整体的，也就是说整张图片一起变亮或者一起变暗，原本比背景亮的目标物体，在较暗环境下同样应该比背景亮。</p><p>基于这一点，我们可以提出一个简易的自适应二值化方法：对图像所有像素的亮度值进行从大到小排序，取前 20%（该数值为人为设定的阈值参数）的像素作为目标，其余为背景。</p><p>OpenCV 中常用的方法有 <code class="language-plaintext highlighter-rouge">大津二值化</code> 方法。对于之前提到的函数 <code class="language-plaintext highlighter-rouge">threshold()</code> ，当 <code class="language-plaintext highlighter-rouge">type = cv::THRESH_OTSU</code> 时，参数 <code class="language-plaintext highlighter-rouge">thresh</code> 无效，具体数值由大津法自行计算，并在函数的返回值中返回。</p><p>下面是一个使用 <code class="language-plaintext highlighter-rouge">大津法</code> 计算 <code class="language-plaintext highlighter-rouge">thresh</code> 的例子。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span text-data=" C++ "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">double</span> <span class="n">thres</span> <span class="o">=</span> <span class="n">cv</span><span class="o">::</span><span class="n">threshold</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">binary_img</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">THRESH_OTSU</span><span class="p">);</span>
</pre></table></code></div></div><p>程序运行的结果与手动设定阈值的结果相似。</p><p><strong>但是设定单一阈值的方法仍然有明显的缺点，对于一张图中有明显的光线亮度渐变的图像，单一阈值往往难以起到好的效果。</strong></p><h4 id="2-局部自适应">2. 局部自适应</h4><p>例如下图这张图片，左侧的亮度明显高于右下角：</p><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/Harry-hhj/Harry-hhj.github.io/master/_posts/2021-10-02-RM-Tutorial-3-Getting-Started-with-OpenCV.assets/newspaper.jpg" alt="newspaper" /></p><p>如果使用大津法自动求阈值并直接二值化，会得到类似下图的结果：</p><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/Harry-hhj/Harry-hhj.github.io/master/_posts/2021-10-02-RM-Tutorial-3-Getting-Started-with-OpenCV.assets/newspaper-bad.jpg" alt="newspaper-bad" /></p><p>为了解决这种问题，我们需要对每个区域局部适应区域内的灰度情况，对每个区域使用不同的阈值分别二值化。 OpenCV 中提供了 <code class="language-plaintext highlighter-rouge">adaptiveThreshold</code> 方法实现这一功能。 函数的声明如下：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span text-data=" C++ "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="n">cv</span><span class="o">::</span><span class="n">adaptiveThreshold</span><span class="p">(</span><span class="n">InputArray</span> <span class="n">src</span><span class="p">,</span> <span class="n">OutputArray</span> <span class="n">dst</span><span class="p">,</span> <span class="kt">double</span> <span class="n">maxValue</span><span class="p">,</span> <span class="kt">int</span> <span class="n">adaptiveMethod</span><span class="p">,</span> <span class="kt">int</span> <span class="n">thresholdType</span><span class="p">,</span> <span class="kt">int</span> <span class="n">blockSize</span><span class="p">,</span> <span class="kt">double</span> <span class="n">C</span><span class="p">)</span>
</pre></table></code></div></div><p>其中：</p><ul><li><code class="language-plaintext highlighter-rouge">adaptiveMethod</code> 为自适应二值化算法使用的方法；<li><code class="language-plaintext highlighter-rouge">blockSize</code> 为自适应二值化的算子大小，注意必须为奇数；<li><code class="language-plaintext highlighter-rouge">C</code> 为用来手动调整阈值的偏置量大小。</ul><p>自适应二值化算法的运行结果如下：</p><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/Harry-hhj/Harry-hhj.github.io/master/_posts/2021-10-02-RM-Tutorial-3-Getting-Started-with-OpenCV.assets/newspaper_adaptive.jpg" alt="newspaper_adaptive" /></p><h3 id="3-基于梯度的边缘">3） 基于梯度的边缘</h3><p>在上述全局的方法中，通过一个阈值将整张图片分为两个部分，而两部分的交界处就作为边缘。这样的一个做法还有另一个缺点，如果图像中有一片区域亮度从低逐渐过渡到高，二值化同样会把这片区域分为两块。即，二值化得出的边缘，并不一定是图像中亮度变化最大（或较大）的地方。由于目标和背景亮度差异较大，所以交界处一定是图像中亮度变化最大（或较大）的地方。</p><p>为了解决该问题，还可以使用基于梯度的边缘。二值化和梯度检测是两种不同的方法。其基本思想是：首先计算图片中每个像素点的亮度梯度大小（一般使用Sobel算子），然后设定一个阈值，梯度高于该阈值的作为边缘点。同样，类似与自适应二值化，这个阈值也可以设定成一个比值。</p><p>在实际使用中，我们通常会使用 Canny 算法进行基于梯度的边缘检测，这个算法中做了很多额外措施，使得边缘检测的效果较好。</p><p>OpenCV 中 Canny 算法的函数声明如下：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span text-data=" C++ "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="n">cv</span><span class="o">::</span><span class="n">Canny</span><span class="p">(</span><span class="n">InputArray</span> <span class="n">image</span><span class="p">,</span> <span class="n">OutputArray</span> <span class="n">edges</span><span class="p">,</span> <span class="kt">double</span> <span class="n">threshold1</span><span class="p">,</span> <span class="kt">double</span> <span class="n">threshold2</span><span class="p">,</span> <span class="kt">int</span> <span class="n">apertureSize</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">L2gradient</span> <span class="o">=</span> <span class="nb">false</span><span class="p">)</span>
</pre></table></code></div></div><p>对于下面这张图：</p><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/Harry-hhj/Harry-hhj.github.io/master/_posts/2021-10-02-RM-Tutorial-3-Getting-Started-with-OpenCV.assets/energy_gray.jpg" alt="energy_gray" /></p><p>我们使用下面的程序进行梯度边缘检测：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span text-data=" C++ "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">task3_img</span> <span class="o">=</span> <span class="n">cv</span><span class="o">::</span><span class="n">imread</span><span class="p">(</span><span class="n">PROJECT_DIR</span><span class="s">"/assets/energy.jpg"</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">IMREAD_GRAYSCALE</span><span class="p">);</span>
<span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">task3_result</span><span class="p">;</span>
<span class="n">cv</span><span class="o">::</span><span class="n">Canny</span><span class="p">(</span><span class="n">task3_img</span><span class="p">,</span> <span class="n">task3_result</span><span class="p">,</span> <span class="mi">125</span><span class="p">,</span> <span class="mi">225</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
<span class="n">cv</span><span class="o">::</span><span class="n">imshow</span><span class="p">(</span><span class="s">"task3_canny"</span><span class="p">,</span> <span class="n">task3_result</span><span class="p">);</span>
<span class="n">cv</span><span class="o">::</span><span class="n">waitKey</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</pre></table></code></div></div><p>程序的结果是：</p><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/Harry-hhj/Harry-hhj.github.io/master/_posts/2021-10-02-RM-Tutorial-3-Getting-Started-with-OpenCV.assets/energy_canny.jpg" alt="energy_canny" /></p><h3 id="4补充检测颜色边缘">4）补充：检测颜色边缘</h3><p>在上面几种方法中，我们都是进行亮度边缘检测，亮度边缘检测有一个明显的特征，即每个像素的亮度都可以用一个数值进行表达。但当我们想进行颜色边缘检测时，我们似乎并不能用一个数值来表达该像素的颜色差异，必须使用 RGB 三通道数值才能表达一个像素的颜色。</p><p>首先，在 RGB 颜色表示方法中，每个颜色分量都包含了该像素点的颜色信息和亮度信息。我们希望对 RGB 颜色表示进行一个变换，使得像素点的颜色信息和亮度信息可以独立开来。为此，我们可以使用 HSV 颜色空间。</p><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/Harry-hhj/Harry-hhj.github.io/master/_posts/2021-10-02-RM-Tutorial-3-Getting-Started-with-OpenCV.assets/hsv.png" alt="img" /><em>hsv 六棱锥</em></p><p>在 HSV 颜色空间中， H 分量代表色度，即该像素是哪种颜色； S 分量代表饱和度； V 分量代表亮度（和光强度之间并没有直接的联系）。这种颜色表示方法很好地将每个像素的颜色、饱和度和亮度独立开。至于 RGB 颜色空间如何转换为 HSV 颜色空间，这里不作介绍，有兴趣可以自行百度。</p><p>有了 HSV 颜色空间，由于其 H 通道就代表了像素的颜色，我们就可以在 H 通道上使用上述几种边缘检测方式，从而得出颜色边缘。</p><p>以下是几种常见颜色的 hsv 阈值，每种颜色对应 HSV 空间中的一块区域，在各通道上呈现一个或两个区间：</p><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/Harry-hhj/Harry-hhj.github.io/master/_posts/2021-10-02-RM-Tutorial-3-Getting-Started-with-OpenCV.assets/900592-20160727130101544-2044756507.png" alt="img" /></p><p>这些数值可以作为调参的一个初值。</p><p>OpenCV 提供了 <code class="language-plaintext highlighter-rouge">inRange()</code> 函数完成区间的筛选：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span text-data=" C++ "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="n">cv</span><span class="o">::</span><span class="n">inRange</span><span class="p">(</span><span class="n">InputArray</span> <span class="n">src</span><span class="p">,</span> <span class="n">InputArray</span> <span class="n">lowerb</span><span class="p">,</span> <span class="n">InputArray</span> <span class="n">upperb</span><span class="p">,</span> <span class="n">OutputArray</span> <span class="n">dst</span><span class="p">)</span>
</pre></table></code></div></div><p>其中 lowerb 和 upperb 分别对应 HSV 空间中坐标范围的下界和上界。</p><p>如果需要提取多个 HSV空间范围中的颜色，那么需要执行多次 inRange 并将得到的颜色取并集。</p><p>我们以下图为例：</p><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/Harry-hhj/Harry-hhj.github.io/master/_posts/2021-10-02-RM-Tutorial-3-Getting-Started-with-OpenCV.assets/energy.jpg" alt="energy" /></p><p>我们想要提取的颜色为红色和橙色的区域，通过百度搜索，我们了解到红色和橙色的颜色在 HSV 空间中处于区间 $[(0, 43, 46), (255, 255, 255)] \cup [(156, 43, 46), (180, 255, 255)]$ 中。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span text-data=" C++ "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">task4_img</span> <span class="o">=</span> <span class="n">cv</span><span class="o">::</span><span class="n">imread</span><span class="p">(</span><span class="n">PROJECT_DIR</span><span class="s">"/assets/energy.jpg"</span><span class="p">);</span>
<span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">task4_hsv</span><span class="p">;</span>
<span class="n">cv</span><span class="o">::</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">task4_img</span><span class="p">,</span> <span class="n">task4_hsv</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">COLOR_BGR2HSV</span><span class="p">);</span>
<span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">task4_hsv_part1</span><span class="p">,</span> <span class="n">task4_hsv_part2</span><span class="p">;</span>
<span class="n">cv</span><span class="o">::</span><span class="n">inRange</span><span class="p">(</span><span class="n">task4_hsv</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">Scalar</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">43</span><span class="p">,</span> <span class="mi">46</span><span class="p">),</span> <span class="n">cv</span><span class="o">::</span><span class="n">Scalar</span><span class="p">(</span><span class="mi">25</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">),</span> <span class="n">task4_hsv_part1</span><span class="p">);</span>
<span class="n">cv</span><span class="o">::</span><span class="n">inRange</span><span class="p">(</span><span class="n">task4_hsv</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">Scalar</span><span class="p">(</span><span class="mi">156</span><span class="p">,</span> <span class="mi">43</span><span class="p">,</span> <span class="mi">46</span><span class="p">),</span> <span class="n">cv</span><span class="o">::</span><span class="n">Scalar</span><span class="p">(</span><span class="mi">180</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">),</span> <span class="n">task4_hsv_part2</span><span class="p">);</span> <span class="c1">// 提取红色和橙色</span>
<span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">task4_ones_mat</span> <span class="o">=</span> <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="o">::</span><span class="n">ones</span><span class="p">(</span><span class="n">cv</span><span class="o">::</span><span class="n">Size</span><span class="p">(</span><span class="n">task4_img</span><span class="p">.</span><span class="n">cols</span><span class="p">,</span> <span class="n">task4_img</span><span class="p">.</span><span class="n">rows</span><span class="p">),</span> <span class="n">CV_8UC1</span><span class="p">);</span>
<span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">task4_hsv_result</span> <span class="o">=</span> <span class="mi">255</span> <span class="o">*</span> <span class="p">(</span><span class="n">task4_ones_mat</span> <span class="o">-</span> <span class="p">(</span><span class="n">task4_ones_mat</span> <span class="o">-</span> <span class="n">task4_hsv_part1</span> <span class="o">/</span> <span class="mi">255</span><span class="p">).</span><span class="n">mul</span><span class="p">(</span><span class="n">task4_ones_mat</span> <span class="o">-</span> <span class="n">task4_hsv_part2</span> <span class="o">/</span> <span class="mi">255</span><span class="p">));</span>
<span class="c1">// 对hsv_part1的结果和hsv_part2的结果取并集</span>
<span class="n">cv</span><span class="o">::</span><span class="n">imshow</span><span class="p">(</span><span class="s">"hsv"</span><span class="p">,</span> <span class="n">task4_hsv_result</span><span class="p">);</span>
<span class="n">cv</span><span class="o">::</span><span class="n">waitKey</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</pre></table></code></div></div><p>程序结果如下：</p><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/Harry-hhj/Harry-hhj.github.io/master/_posts/2021-10-02-RM-Tutorial-3-Getting-Started-with-OpenCV.assets/energy_hsv_result.jpg" alt="energy_hsv_result" /></p><p>当然， HSV 颜色提取虽然是一种非常优秀的二值化方法，但他也存在自己的局限性。例如亮度的变化会对 HSV 数值造成干扰。同时，在实际使用过程中，如果相机的感光元件敏感度较高，也会造成图像中出现噪点，形成椒盐噪声。此外，在感光角度不同时，相机获取到的颜色饱和度和色相也会发生一定程度的变化，造成 HSV空洞 。</p><p>这里我们顺便提供一段 HSV 的调参界面代码：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span text-data=" C++ "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">HSV_calib</span><span class="p">(</span><span class="k">const</span> <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">img</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">thres</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// mode: 0 for red; 1 for green; 2 for blue;</span>
    <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">imgHSV</span><span class="p">;</span>
    <span class="n">cv</span><span class="o">::</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">imgHSV</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">COLOR_BGR2HSV</span><span class="p">);</span>

    <span class="n">cv</span><span class="o">::</span><span class="n">namedWindow</span><span class="p">(</span><span class="s">"Control"</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">WINDOW_AUTOSIZE</span><span class="p">);</span> <span class="c1">//create a window called "Control"</span>
    <span class="n">thres</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="mi">156</span> <span class="o">:</span> <span class="p">((</span><span class="n">mode</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="mi">100</span> <span class="o">:</span> <span class="mi">35</span><span class="p">);</span>
    <span class="n">thres</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="mi">180</span> <span class="o">:</span> <span class="p">((</span><span class="n">mode</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="mi">140</span> <span class="o">:</span> <span class="mi">70</span><span class="p">);</span>
    <span class="n">thres</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="mi">43</span> <span class="o">:</span> <span class="p">((</span><span class="n">mode</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="mi">90</span> <span class="o">:</span> <span class="mi">43</span><span class="p">);</span>
    <span class="n">thres</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="mi">255</span> <span class="o">:</span> <span class="p">((</span><span class="n">mode</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="mi">255</span> <span class="o">:</span> <span class="mi">255</span><span class="p">);</span>
    <span class="n">thres</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="mi">46</span> <span class="o">:</span> <span class="p">((</span><span class="n">mode</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="mi">90</span> <span class="o">:</span> <span class="mi">43</span><span class="p">);</span>
    <span class="n">thres</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="mi">255</span> <span class="o">:</span> <span class="p">((</span><span class="n">mode</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="mi">255</span> <span class="o">:</span> <span class="mi">255</span><span class="p">);</span>
    <span class="c1">//Create trackbars in "Control" window</span>
    <span class="n">cv</span><span class="o">::</span><span class="n">createTrackbar</span><span class="p">(</span><span class="s">"LowH"</span><span class="p">,</span> <span class="s">"Control"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">thres</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">179</span><span class="p">);</span> <span class="c1">//Hue (0 - 179)</span>
    <span class="n">cv</span><span class="o">::</span><span class="n">createTrackbar</span><span class="p">(</span><span class="s">"HighH"</span><span class="p">,</span> <span class="s">"Control"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">thres</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">179</span><span class="p">);</span>
    <span class="n">cv</span><span class="o">::</span><span class="n">createTrackbar</span><span class="p">(</span><span class="s">"LowS"</span><span class="p">,</span> <span class="s">"Control"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">thres</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">255</span><span class="p">);</span> <span class="c1">//Saturation (0 - 255)</span>
    <span class="n">cv</span><span class="o">::</span><span class="n">createTrackbar</span><span class="p">(</span><span class="s">"HighS"</span><span class="p">,</span> <span class="s">"Control"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">thres</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">255</span><span class="p">);</span>
    <span class="n">cv</span><span class="o">::</span><span class="n">createTrackbar</span><span class="p">(</span><span class="s">"LowV"</span><span class="p">,</span> <span class="s">"Control"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">thres</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">255</span><span class="p">);</span> <span class="c1">//Value (0 - 255)</span>
    <span class="n">cv</span><span class="o">::</span><span class="n">createTrackbar</span><span class="p">(</span><span class="s">"HighV"</span><span class="p">,</span> <span class="s">"Control"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">thres</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="mi">255</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="o">&gt;</span> <span class="n">hsvSplit</span><span class="p">;</span>
    <span class="c1">//因为我们读取的是彩色图，直方图均衡化需要在HSV空间做</span>
    <span class="n">cv</span><span class="o">::</span><span class="n">split</span><span class="p">(</span><span class="n">imgHSV</span><span class="p">,</span> <span class="n">hsvSplit</span><span class="p">);</span>

    <span class="n">cv</span><span class="o">::</span><span class="n">equalizeHist</span><span class="p">(</span><span class="n">hsvSplit</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">hsvSplit</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
    <span class="n">cv</span><span class="o">::</span><span class="n">merge</span><span class="p">(</span><span class="n">hsvSplit</span><span class="p">,</span> <span class="n">imgHSV</span><span class="p">);</span>
    <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">imgThresholded</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cv</span><span class="o">::</span><span class="n">inRange</span><span class="p">(</span><span class="n">imgHSV</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">Scalar</span><span class="p">(</span><span class="n">thres</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">thres</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">thres</span><span class="p">[</span><span class="mi">4</span><span class="p">]),</span> <span class="n">cv</span><span class="o">::</span><span class="n">Scalar</span><span class="p">(</span><span class="n">thres</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">thres</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">thres</span><span class="p">[</span><span class="mi">5</span><span class="p">]),</span>
                    <span class="n">imgThresholded</span><span class="p">);</span> <span class="c1">//Threshold the image</span>

        <span class="c1">//开操作 (去除一些噪点)</span>
        <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">element</span> <span class="o">=</span> <span class="n">getStructuringElement</span><span class="p">(</span><span class="n">cv</span><span class="o">::</span><span class="n">MORPH_RECT</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">Size</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">));</span>
        <span class="n">cv</span><span class="o">::</span><span class="n">morphologyEx</span><span class="p">(</span><span class="n">imgThresholded</span><span class="p">,</span> <span class="n">imgThresholded</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">MORPH_OPEN</span><span class="p">,</span> <span class="n">element</span><span class="p">);</span>

        <span class="c1">//闭操作 (连接一些连通域)</span>
        <span class="n">cv</span><span class="o">::</span><span class="n">morphologyEx</span><span class="p">(</span><span class="n">imgThresholded</span><span class="p">,</span> <span class="n">imgThresholded</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">MORPH_CLOSE</span><span class="p">,</span> <span class="n">element</span><span class="p">);</span>

        <span class="n">cv</span><span class="o">::</span><span class="n">imshow</span><span class="p">(</span><span class="s">"Thresholded Image"</span><span class="p">,</span> <span class="n">imgThresholded</span><span class="p">);</span> <span class="c1">//show the thresholded image</span>
        <span class="n">cv</span><span class="o">::</span><span class="n">imshow</span><span class="p">(</span><span class="s">"Original"</span><span class="p">,</span> <span class="n">img</span><span class="p">);</span> <span class="c1">//show the original image</span>

        <span class="kt">char</span> <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="p">)</span> <span class="n">cv</span><span class="o">::</span><span class="n">waitKey</span><span class="p">(</span><span class="mi">300</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">key</span> <span class="o">==</span> <span class="mi">27</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">cv</span><span class="o">::</span><span class="n">destroyWindow</span><span class="p">(</span><span class="s">"Control"</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="四边缘检测的后处理">四、边缘检测的后处理</h2><p>不论是使用二值化、还是自适应二值化、还是基于梯度的边缘检测方法，其检测结果都不可能正好分毫不差的将目标完整保留下来，并将背景完全剔除。即使图像质量极佳，或者目标特征极为明显，使得正好将目标和背景区分开，检测结果也还停留于像素层面，即每个像素是目标还是背景，而我们想要的则是目标在哪片区域。</p><p>所以后处理的目的主要有三个：<strong>剔除错误的背景边缘、补充缺失的目标边缘、将目标表达成一个区域</strong>。</p><p>对于前两点，我们通常会首先使用开闭运算处理二值化图或边缘图（取决于之前你采用的策略）。其中开运算连接断开区域，闭运算删除游离的噪声区域。详细算法的计算方式，这里不作介绍，有兴趣可以自行百度。图像滤波亦能达到类似的效果。</p><p>对于第三点，我们会使用轮廓检测。轮廓可以理解为一系列连通的边缘点，并且这些边缘点可以构成一个闭合曲线。</p><h3 id="1滤波">1）滤波</h3><p>滤波通常是对二值化方法使用的。在对现实中的图像进行二值化时，二值化的结果往往难以达到最佳状态。许多情况下，二值化会产生空洞或形成噪点。在这种情况下就需要滤波和形态学运算这两大工具来提升二值化结果的质量。</p><p>滤波类似于卷积，有一个叫做算子的东西处理图像的局部特征。在开始之前，我们本节中的所有实例会针对以下图片进行。</p><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/Harry-hhj/Harry-hhj.github.io/master/_posts/2021-10-02-RM-Tutorial-3-Getting-Started-with-OpenCV.assets/noise.jpg" alt="noise" /></p><p>下面介绍几个比较常用的滤波算法。</p><h4 id="1-均值滤波">1. 均值滤波</h4><p>均值滤波是最简单的滤波，也被成为线性平滑滤波。其算子可以表达为： \(K = \cfrac{1}{\text{ksize.width} \times \text{ksize.height}} \begin{bmatrix} 1&amp;1&amp;\cdots&amp;1\\ \vdots&amp;\vdots&amp;\ddots&amp;\vdots\\ 1&amp;1&amp;\cdots&amp;1\\ \end{bmatrix}\) 即对大小为 $M \times N$的矩形框内的像素取平均值。</p><p>OpenCV 中对应的函数是：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span text-data=" C++ "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="n">cv</span><span class="o">::</span><span class="n">blur</span><span class="p">(</span><span class="n">InputArray</span> <span class="n">src</span><span class="p">,</span> <span class="n">OutputArray</span> <span class="n">dst</span><span class="p">,</span> <span class="n">Size</span> <span class="n">ksize</span><span class="p">,</span> <span class="n">Point</span> <span class="n">anchor</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="kt">int</span> <span class="n">borderType</span> <span class="o">=</span> <span class="n">BORDER_DEFAULT</span><span class="p">)</span>
</pre></table></code></div></div><p>对例子中的图片应用均值滤波：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span text-data=" C++ "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">blured_img</span><span class="p">;</span>
<span class="n">cv</span><span class="o">::</span><span class="n">blur</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">task5_blured_img</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">Size</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">));</span>
</pre></table></code></div></div><p>结果如下</p><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/Harry-hhj/Harry-hhj.github.io/master/_posts/2021-10-02-RM-Tutorial-3-Getting-Started-with-OpenCV.assets/noise_blurred.jpg" alt="noise_blurred" /></p><p>中值滤波的效果是使得图片更加模糊，削弱噪声的边缘梯度，使其看起来不那么显著，但是噪声本身并没有得到很好的消除，同时有用的信息也被削弱了。均值滤波是最快速的滤波算法之一，但同时它的效果却也不够理想，一般无法有效地去除椒盐噪声。</p><h4 id="2-高斯滤波">2. 高斯滤波</h4><p>高斯滤波通过对图像卷积高斯滤波算子实现滤波的效果。高斯算子如下： \(G(x, y) = \cfrac{1}{2\pi\rho^2} e^{-c\frac{x^2+y^2}{2\rho^2}}\) 例如这就是一个高斯算子： \(\frac{1}{16} \times \begin{bmatrix} 1&amp;2&amp;1\\ 2&amp;4&amp;2\\ 1&amp;2&amp;1\\ \end{bmatrix}\) 高斯算子的思想是：有用的信息会以一定的数量聚在一起，而噪声是随机游离的；最中间的信息对于该位数据最有用，但也应当考虑边缘信息的影响。</p><p>OpenCV 中对应的函数是：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span text-data=" C++ "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="n">cv</span><span class="o">::</span><span class="n">GaussianBlur</span><span class="p">(</span><span class="n">InputArray</span> <span class="n">src</span><span class="p">,</span> <span class="n">OutputArray</span> <span class="n">dst</span><span class="p">,</span> <span class="n">Size</span> <span class="n">ksize</span><span class="p">,</span> <span class="kt">double</span> <span class="n">sigmaX</span><span class="p">,</span> <span class="kt">double</span> <span class="n">sigmaY</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">borderType</span> <span class="o">=</span> <span class="n">BORDER_DEFAULT</span><span class="p">)</span>
</pre></table></code></div></div><p>其中</p><ul><li><code class="language-plaintext highlighter-rouge">ksize</code> 为高斯算子的大小<li><code class="language-plaintext highlighter-rouge">sigmaX</code> 和 <code class="language-plaintext highlighter-rouge">sigmaY</code> 为高斯函数在 x 和 y 方向上的偏置</ul><p>对例子中的图片应用高斯滤波：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span text-data=" C++ "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">gaussian_blured_img</span><span class="p">;</span>
<span class="n">cv</span><span class="o">::</span><span class="n">GaussianBlur</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">gaussian_blured_img</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">Size</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</pre></table></code></div></div><p>结果如下</p><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/Harry-hhj/Harry-hhj.github.io/master/_posts/2021-10-02-RM-Tutorial-3-Getting-Started-with-OpenCV.assets/noise_guassian_blurred.jpg" alt="noise_guassian_blurred" /></p><p>可以看到虽然结果的噪声仍然很大，但图像在平滑效果和特征保留上相对均值滤波都有一定的提升，例如边缘信息更加明显一些。</p><h4 id="3-中值滤波">3. 中值滤波</h4><p>中值滤波与前两者最大的不同在于，均值滤波和高斯滤波均为线性滤波，而中值滤波为非线性滤波。非线性滤波相对于线型滤波，往往都有更好的滤波效果，但代价是会有远高于线型滤波的时间开销。</p><p>中值滤波是基于排序统计理论的一种能有效抑制噪声的非线性信号处理技术，基本原理是把数字图像或数字序列中一点的值用该点的一个邻域中各点值的中值代替，让周围的像素值接近的真实值，从而消除孤立的噪声点。中值滤波对于滤除脉冲干扰及图像扫描噪声最为有效，还可以克服线性滤波器（如邻域简单平滑滤波）带来的图像细节模糊。</p><p>中值滤波算子不易用公式描述，总结如下：用某种结构的二维滑动模板，将板内像素按照像素值的大小进行排序，生成单调上升（或下降）的为二维数据序列。二维中值滤波输出为 $g(x,y)=med{f(x-k,y-l),\ k,l \in W}$ ，其中 $f(x,y)$ ， $g(x,y)$ 分别为原始图像和处理后图像。 $W$ 为二维模板，通常为 $3\times3$ ， $5\times5$ 区域，也可以是不同的的形状，如线状、圆形、十字形圆、环形等。</p><p>对例子中的图片应用中值滤波：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span text-data=" C++ "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">median_blured_img</span><span class="p">;</span>
<span class="n">cv</span><span class="o">::</span><span class="n">medianBlur</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">median_blured_img</span><span class="p">,</span> <span class="mi">7</span><span class="p">);</span>
</pre></table></code></div></div><p>结果如下</p><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/Harry-hhj/Harry-hhj.github.io/master/_posts/2021-10-02-RM-Tutorial-3-Getting-Started-with-OpenCV.assets/noise_median_blurred.jpg" alt="noise_median_blurred" /></p><p>可以看到中值滤波在去除椒盐噪声上有着良好的表现，但在信息的保存上劣于高斯滤波。中值滤波不仅对孤立杂点的消除效果显著，对稍密集的杂点也有很好的去除效果。</p><h3 id="2形态学处理">2）形态学处理</h3><p>形态学处理一般处理二值图像。</p><p>结构元（Structuring Elements）：一般有矩形和十字形。结构元有一个锚点 O ，O 一般定义为结构元的中心。下图是几个不同形状的结构元，紫红色块为锚点 O 。</p><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/Harry-hhj/Harry-hhj.github.io/master/_posts/2021-10-02-RM-Tutorial-3-Getting-Started-with-OpenCV.assets/v2-f9264db4ca737c71cf7d21eb442a74f3_1440w.jpg" alt="img" /></p><p>常见的形态学运算有腐蚀、膨胀、开闭，常用于中击不中变换、边界提取和跟踪、区域填充、提取连通分量、细化和像素化， 以及凸壳。</p><p>OpenCV 中构造结构元的函数是</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span text-data=" C++ "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="nf">getStructuringElement</span><span class="p">(</span><span class="kt">int</span> <span class="n">shape</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">Size</span> <span class="n">esize</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">Point</span> <span class="n">anchor</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">));</span>
</pre></table></code></div></div><p>参数：</p><ul><li><code class="language-plaintext highlighter-rouge">shape</code> ：内核的形状，有三种形状可以选择<ul><li><code class="language-plaintext highlighter-rouge">cv::MORPH_RECT</code> ：矩形<li><code class="language-plaintext highlighter-rouge">cv::MORPH_CROSS</code> ：交叉形<li><code class="language-plaintext highlighter-rouge">cv::MORPH_ELLIPSE</code> ：椭圆形</ul></ul><p>为了增强例子的可展示性，下面的例子中都采用了大结构元，但平时我们一般不会用那么大。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span text-data=" C++ "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">element</span> <span class="o">=</span> <span class="n">cv</span><span class="o">::</span><span class="n">getStructuringElement</span><span class="p">(</span><span class="n">cv</span><span class="o">::</span><span class="n">MORPH_CROSS</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">Size</span><span class="p">(</span><span class="mi">21</span><span class="p">,</span> <span class="mi">21</span><span class="p">));</span>
</pre></table></code></div></div><h4 id="膨胀-dilation">膨胀 Dilation</h4><p>将结构元 $s$ 在图像 $f$ 上滑动，把结构元<strong>锚点位置的图像像素点</strong>的灰度值设置为<strong>结构元值为1的区域</strong>对应图像区域像素的<strong>最大值</strong>。</p><p>膨胀运算示意图如下，从视觉上看图像中的前景仿佛“膨胀”了一样：</p><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/Harry-hhj/Harry-hhj.github.io/master/_posts/2021-10-02-RM-Tutorial-3-Getting-Started-with-OpenCV.assets/v2-706dbd8d0eacdaf61b3595b2de4f18b2_1440w.jpg" alt="img" /></p><p>OpenCV 中的实现函数是</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span text-data=" C++ "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">dilate</span><span class="p">(</span><span class="n">InputArray</span> <span class="n">src</span><span class="p">,</span> <span class="n">OutputArray</span> <span class="n">dst</span><span class="p">,</span> <span class="n">InputArray</span> <span class="n">kernel</span><span class="p">,</span> <span class="n">Point</span> <span class="n">anchor</span><span class="o">=</span><span class="n">Point</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="kt">int</span> <span class="n">iterations</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">borderType</span><span class="o">=</span><span class="n">BORDER_CONSTANT</span><span class="p">,</span> <span class="k">const</span> <span class="n">Scalar</span><span class="o">&amp;</span> <span class="n">borderValue</span><span class="o">=</span><span class="n">morphologyDefaultBorderValue</span><span class="p">());</span>
</pre></table></code></div></div><p>对中值滤波的结果图进行膨胀：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span text-data=" C++ "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">task7_src</span> <span class="o">=</span> <span class="n">task5_median_blured_img</span><span class="p">.</span><span class="n">clone</span><span class="p">();</span>
<span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">element</span> <span class="o">=</span> <span class="n">cv</span><span class="o">::</span><span class="n">getStructuringElement</span><span class="p">(</span><span class="n">cv</span><span class="o">::</span><span class="n">MORPH_CROSS</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">Size</span><span class="p">(</span><span class="mi">21</span><span class="p">,</span> <span class="mi">21</span><span class="p">));</span>
<span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">task7_dilated</span><span class="p">;</span>
<span class="n">cv</span><span class="o">::</span><span class="n">dilate</span><span class="p">(</span><span class="n">task7_src</span><span class="p">,</span> <span class="n">task7_dilated</span><span class="p">,</span> <span class="n">element</span><span class="p">);</span>
<span class="n">cv</span><span class="o">::</span><span class="n">imshow</span><span class="p">(</span><span class="s">"dilate"</span><span class="p">,</span> <span class="n">task7_dilated</span><span class="p">);</span>
<span class="n">cv</span><span class="o">::</span><span class="n">waitKey</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</pre></table></code></div></div><p>效果如下：</p><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/Harry-hhj/Harry-hhj.github.io/master/_posts/2021-10-02-RM-Tutorial-3-Getting-Started-with-OpenCV.assets/dilated.jpg" alt="dilated" /></p><h4 id="腐蚀-erosion">腐蚀 Erosion</h4><p>将结构元 $s$ 在图像 $f$ 上滑动，把结构元<strong>锚点位置的图像像素点</strong>的灰度值设置为<strong>结构元值为 1 的区域</strong>对应图像区域像素的<strong>最小值</strong>。</p><p>腐蚀运算示意图如下，从视觉上看图像中的前景仿佛被“腐蚀”了一样：</p><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/Harry-hhj/Harry-hhj.github.io/master/_posts/2021-10-02-RM-Tutorial-3-Getting-Started-with-OpenCV.assets/v2-dad3db32195f9849bff5f27428f293f2_1440w.jpg" alt="img" /></p><p>OpenCV 中的实现函数是</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span text-data=" C++ "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">erode</span><span class="p">(</span><span class="n">InputArray</span> <span class="n">src</span><span class="p">,</span> <span class="n">OutputArray</span> <span class="n">dst</span><span class="p">,</span> <span class="n">InputArray</span> <span class="n">kernel</span><span class="p">,</span> <span class="n">Point</span> <span class="n">anchor</span><span class="o">=</span><span class="n">Point</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="kt">int</span> <span class="n">iterations</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">borderType</span><span class="o">=</span><span class="n">BORDER_CONSTANT</span><span class="p">,</span> <span class="k">const</span> <span class="n">Scalar</span><span class="o">&amp;</span> <span class="n">borderValue</span><span class="o">=</span><span class="n">morphologyDefaultBorderValue</span><span class="p">());</span>
</pre></table></code></div></div><p>对中值滤波的结果图进行膨胀：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span text-data=" C++ "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">task7_src</span> <span class="o">=</span> <span class="n">task5_median_blured_img</span><span class="p">.</span><span class="n">clone</span><span class="p">();</span>
<span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">task7_eroded</span><span class="p">;</span>
<span class="n">cv</span><span class="o">::</span><span class="n">erode</span><span class="p">(</span><span class="n">task7_src</span><span class="p">,</span> <span class="n">task7_eroded</span><span class="p">,</span> <span class="n">element</span><span class="p">);</span>
<span class="n">cv</span><span class="o">::</span><span class="n">imshow</span><span class="p">(</span><span class="s">"eroded"</span><span class="p">,</span> <span class="n">task7_eroded</span><span class="p">);</span>
<span class="n">cv</span><span class="o">::</span><span class="n">waitKey</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</pre></table></code></div></div><p>效果如下：</p><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/Harry-hhj/Harry-hhj.github.io/master/_posts/2021-10-02-RM-Tutorial-3-Getting-Started-with-OpenCV.assets/eroded.jpg" alt="eroded" /></p><h4 id="开运算-opening">开运算 Opening</h4><p>对图像 $f$ 用同一结构元 $s$ 先腐蚀再膨胀称之为开运算。</p><p>开运算示意图如下，从视觉上看仿佛将原本连接的物体“分开”了一样：</p><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/Harry-hhj/Harry-hhj.github.io/master/_posts/2021-10-02-RM-Tutorial-3-Getting-Started-with-OpenCV.assets/v2-df1184167b6ecd67b139093fe6e57be5_1440w.jpg" alt="img" /></p><p>开运算能够除去孤立的小点，毛刺和小桥，而总的位置和形状不便。</p><p>OpenCV 中的实现函数是</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span text-data=" C++ "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">morphologyEx</span><span class="p">(</span><span class="n">InputArray</span> <span class="n">src</span><span class="p">,</span> <span class="n">OutputArray</span> <span class="n">dst</span><span class="p">,</span> <span class="kt">int</span> <span class="n">op</span><span class="p">,</span> <span class="n">InputArray</span> <span class="n">kernel</span><span class="p">,</span> <span class="n">Point</span> <span class="n">anchor</span><span class="o">=</span><span class="n">Point</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="kt">int</span> <span class="n">iterations</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">borderType</span><span class="o">=</span><span class="n">BORDER_CONSTANT</span><span class="p">,</span> <span class="k">const</span> <span class="n">Scalar</span><span class="o">&amp;</span> <span class="n">borderValue</span><span class="o">=</span><span class="n">morphologyDefaultBorderValue</span><span class="p">());</span>
</pre></table></code></div></div><p>参数：</p><ul><li><code class="language-plaintext highlighter-rouge">op</code> ：表示形态学运算的类型<ul><li><code class="language-plaintext highlighter-rouge">MORPH_OPEN</code> – 开运算（Opening operation）<li><code class="language-plaintext highlighter-rouge">MORPH_CLOSE</code> – 闭运算（Closing operation）<li><code class="language-plaintext highlighter-rouge">MORPH_GRADIENT</code> - 形态学梯度（Morphological gradient）<li><code class="language-plaintext highlighter-rouge">MORPH_TOPHAT</code> - 顶帽（Top hat）<li><code class="language-plaintext highlighter-rouge">MORPH_BLACKHAT</code> - 黑帽（Black hat）</ul></ul><p>对中值滤波的结果图进行膨胀：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span text-data=" C++ "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">task7_src</span> <span class="o">=</span> <span class="n">task5_median_blured_img</span><span class="p">.</span><span class="n">clone</span><span class="p">();</span>
<span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">task7_opened</span><span class="p">;</span>
<span class="n">cv</span><span class="o">::</span><span class="n">morphologyEx</span><span class="p">(</span><span class="n">task7_src</span><span class="p">,</span> <span class="n">task7_opened</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">MORPH_OPEN</span><span class="p">,</span> <span class="n">element</span><span class="p">);</span>
<span class="n">cv</span><span class="o">::</span><span class="n">imshow</span><span class="p">(</span><span class="s">"open"</span><span class="p">,</span> <span class="n">task7_opened</span><span class="p">);</span>
<span class="n">cv</span><span class="o">::</span><span class="n">waitKey</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</pre></table></code></div></div><p>效果如下：</p><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/Harry-hhj/Harry-hhj.github.io/master/_posts/2021-10-02-RM-Tutorial-3-Getting-Started-with-OpenCV.assets/opened.jpg" alt="opened" /></p><h4 id="闭运算-closing">闭运算 Closing</h4><p>对图像 $f$ 用同一结构元 $s$ 先膨胀再腐蚀称之为闭运算。</p><p>开运算示意图如下，从视觉上看仿佛将原本分开的部分“闭合”了一样：</p><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/Harry-hhj/Harry-hhj.github.io/master/_posts/2021-10-02-RM-Tutorial-3-Getting-Started-with-OpenCV.assets/v2-2673a7922d457e36998759384d627492_1440w.jpg" alt="img" /></p><p>闭运算能够填平小湖（即小孔），弥合小裂缝，而总的位置和形状不变。</p><p>OpenCV 中的实现函数同开运算。</p><p>对中值滤波的结果图进行膨胀：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span text-data=" C++ "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">task7_src</span> <span class="o">=</span> <span class="n">task5_median_blured_img</span><span class="p">.</span><span class="n">clone</span><span class="p">();</span>
<span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">task7_closed</span><span class="p">;</span>
<span class="n">cv</span><span class="o">::</span><span class="n">morphologyEx</span><span class="p">(</span><span class="n">task7_src</span><span class="p">,</span> <span class="n">task7_closed</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">MORPH_CLOSE</span><span class="p">,</span> <span class="n">element</span><span class="p">);</span>
<span class="n">cv</span><span class="o">::</span><span class="n">imshow</span><span class="p">(</span><span class="s">"close"</span><span class="p">,</span> <span class="n">task7_closed</span><span class="p">);</span>
<span class="n">cv</span><span class="o">::</span><span class="n">waitKey</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</pre></table></code></div></div><p>效果如下：</p><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/Harry-hhj/Harry-hhj.github.io/master/_posts/2021-10-02-RM-Tutorial-3-Getting-Started-with-OpenCV.assets/closed.jpg" alt="closed" /></p><h4 id="其他">其他</h4><p>下面提供一段比较实用的代码，通过以下代码，你可以轻松地去除二值图中大于或者小于某一面积的区域而不需要进行轮廓提取：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span text-data=" C++ "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
</pre><td class="rouge-code"><pre><span class="c1">// CheckMode:  0 代表去除黑区域， 1 代表去除白区域; NeihborMode： 0 代表 4 邻域， 1 代表 8 邻域;</span>
<span class="kt">void</span> <span class="nf">RemoveSmallRegion</span><span class="p">(</span><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="o">&amp;</span><span class="n">Src</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="o">&amp;</span><span class="n">Dst</span><span class="p">,</span> <span class="kt">int</span> <span class="n">AreaLimit</span><span class="p">,</span> <span class="kt">int</span> <span class="n">CheckMode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">NeihborMode</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">RemoveCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>       <span class="c1">// 记录除去的个数</span>
    <span class="c1">// 记录每个像素点检验状态的标签， 0 代表未检查， 1 代表正在检查， 2 代表检查不合格（需要反转颜色）， 3 代表检查合格或不需检查</span>
    <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">Pointlabel</span> <span class="o">=</span> <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="o">::</span><span class="n">zeros</span><span class="p">(</span><span class="n">Src</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">CV_8UC1</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">CheckMode</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
<span class="c1">//        std::cout &lt;&lt; "Mode: 去除小区域. ";</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">Src</span><span class="p">.</span><span class="n">rows</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">uchar</span> <span class="o">*</span><span class="n">iData</span> <span class="o">=</span> <span class="n">Src</span><span class="p">.</span><span class="n">ptr</span><span class="o">&lt;</span><span class="n">uchar</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
            <span class="n">uchar</span> <span class="o">*</span><span class="n">iLabel</span> <span class="o">=</span> <span class="n">Pointlabel</span><span class="p">.</span><span class="n">ptr</span><span class="o">&lt;</span><span class="n">uchar</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">Src</span><span class="p">.</span><span class="n">cols</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">iData</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">iLabel</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="c1">//        std::cout &lt;&lt; "Mode: 去除孔洞. ";</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">Src</span><span class="p">.</span><span class="n">rows</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">uchar</span> <span class="o">*</span><span class="n">iData</span> <span class="o">=</span> <span class="n">Src</span><span class="p">.</span><span class="n">ptr</span><span class="o">&lt;</span><span class="n">uchar</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
            <span class="n">uchar</span> <span class="o">*</span><span class="n">iLabel</span> <span class="o">=</span> <span class="n">Pointlabel</span><span class="p">.</span><span class="n">ptr</span><span class="o">&lt;</span><span class="n">uchar</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">Src</span><span class="p">.</span><span class="n">cols</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">iData</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">iLabel</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">cv</span><span class="o">::</span><span class="n">Point2i</span><span class="o">&gt;</span> <span class="n">NeihborPos</span><span class="p">;</span>  <span class="c1">// 记录邻域点位置</span>
    <span class="n">NeihborPos</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">cv</span><span class="o">::</span><span class="n">Point2i</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
    <span class="n">NeihborPos</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">cv</span><span class="o">::</span><span class="n">Point2i</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
    <span class="n">NeihborPos</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">cv</span><span class="o">::</span><span class="n">Point2i</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">));</span>
    <span class="n">NeihborPos</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">cv</span><span class="o">::</span><span class="n">Point2i</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">NeihborMode</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
<span class="c1">//        std::cout &lt;&lt; "Neighbor mode: 8 邻域." &lt;&lt; std::endl;</span>
        <span class="n">NeihborPos</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">cv</span><span class="o">::</span><span class="n">Point2i</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">));</span>
        <span class="n">NeihborPos</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">cv</span><span class="o">::</span><span class="n">Point2i</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
        <span class="n">NeihborPos</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">cv</span><span class="o">::</span><span class="n">Point2i</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">));</span>
        <span class="n">NeihborPos</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">cv</span><span class="o">::</span><span class="n">Point2i</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="c1">// else std::cout &lt;&lt; "Neighbor mode: 4 邻域." &lt;&lt; std::endl;</span>
    <span class="kt">int</span> <span class="n">NeihborCount</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">NeihborMode</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">CurrX</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">CurrY</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">// 开始检测</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">Src</span><span class="p">.</span><span class="n">rows</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">uchar</span> <span class="o">*</span><span class="n">iLabel</span> <span class="o">=</span> <span class="n">Pointlabel</span><span class="p">.</span><span class="n">ptr</span><span class="o">&lt;</span><span class="n">uchar</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">Src</span><span class="p">.</span><span class="n">cols</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">iLabel</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">//********开始该点处的检查**********</span>
                <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">cv</span><span class="o">::</span><span class="n">Point2i</span><span class="o">&gt;</span> <span class="n">GrowBuffer</span><span class="p">;</span>  <span class="c1">// 堆栈，用于存储生长点</span>
                <span class="n">GrowBuffer</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">cv</span><span class="o">::</span><span class="n">Point2i</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">));</span>
                <span class="n">Pointlabel</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="n">uchar</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
                <span class="kt">int</span> <span class="n">CheckResult</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// 用于判断结果（是否超出大小），0为未超出，1为超出</span>

                <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">z</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">z</span> <span class="o">&lt;</span> <span class="n">GrowBuffer</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">z</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

                    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">q</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">q</span> <span class="o">&lt;</span> <span class="n">NeihborCount</span><span class="p">;</span> <span class="n">q</span><span class="o">++</span><span class="p">)</span>  <span class="c1">//检查四个邻域点</span>
                    <span class="p">{</span>
                        <span class="n">CurrX</span> <span class="o">=</span> <span class="n">GrowBuffer</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">z</span><span class="p">).</span><span class="n">x</span> <span class="o">+</span> <span class="n">NeihborPos</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">q</span><span class="p">).</span><span class="n">x</span><span class="p">;</span>
                        <span class="n">CurrY</span> <span class="o">=</span> <span class="n">GrowBuffer</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">z</span><span class="p">).</span><span class="n">y</span> <span class="o">+</span> <span class="n">NeihborPos</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">q</span><span class="p">).</span><span class="n">y</span><span class="p">;</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">CurrX</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">CurrX</span> <span class="o">&lt;</span> <span class="n">Src</span><span class="p">.</span><span class="n">cols</span> <span class="o">&amp;&amp;</span> <span class="n">CurrY</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">CurrY</span> <span class="o">&lt;</span> <span class="n">Src</span><span class="p">.</span><span class="n">rows</span><span class="p">)</span>  <span class="c1">// 防止越界</span>
                        <span class="p">{</span>
                            <span class="k">if</span> <span class="p">(</span><span class="n">Pointlabel</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="n">uchar</span><span class="o">&gt;</span><span class="p">(</span><span class="n">CurrY</span><span class="p">,</span> <span class="n">CurrX</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                                <span class="n">GrowBuffer</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">cv</span><span class="o">::</span><span class="n">Point2i</span><span class="p">(</span><span class="n">CurrX</span><span class="p">,</span> <span class="n">CurrY</span><span class="p">));</span>  <span class="c1">// 邻域点加入buffer</span>
                                <span class="n">Pointlabel</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="n">uchar</span><span class="o">&gt;</span><span class="p">(</span><span class="n">CurrY</span><span class="p">,</span> <span class="n">CurrX</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1">// 更新邻域点的检查标签，避免重复检查</span>
                            <span class="p">}</span>
                        <span class="p">}</span>
                    <span class="p">}</span>

                <span class="p">}</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">GrowBuffer</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">AreaLimit</span><span class="p">)</span> <span class="n">CheckResult</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>  <span class="c1">//判断结果（是否超出限定的大小），1为未超出，2为超出</span>
                <span class="k">else</span> <span class="p">{</span>
                    <span class="n">CheckResult</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
                    <span class="n">RemoveCount</span><span class="o">++</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">z</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">z</span> <span class="o">&lt;</span> <span class="n">GrowBuffer</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">z</span><span class="o">++</span><span class="p">)</span>  <span class="c1">//更新Label记录</span>
                <span class="p">{</span>
                    <span class="n">CurrX</span> <span class="o">=</span> <span class="n">GrowBuffer</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">z</span><span class="p">).</span><span class="n">x</span><span class="p">;</span>
                    <span class="n">CurrY</span> <span class="o">=</span> <span class="n">GrowBuffer</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">z</span><span class="p">).</span><span class="n">y</span><span class="p">;</span>
                    <span class="n">Pointlabel</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="n">uchar</span><span class="o">&gt;</span><span class="p">(</span><span class="n">CurrY</span><span class="p">,</span> <span class="n">CurrX</span><span class="p">)</span> <span class="o">+=</span> <span class="n">CheckResult</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="c1">//********结束该点处的检查**********</span>


            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">CheckMode</span> <span class="o">=</span> <span class="mi">255</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">CheckMode</span><span class="p">);</span>
    <span class="c1">//开始反转面积过小的区域</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">Src</span><span class="p">.</span><span class="n">rows</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">uchar</span> <span class="o">*</span><span class="n">iData</span> <span class="o">=</span> <span class="n">Src</span><span class="p">.</span><span class="n">ptr</span><span class="o">&lt;</span><span class="n">uchar</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="n">uchar</span> <span class="o">*</span><span class="n">iDstData</span> <span class="o">=</span> <span class="n">Dst</span><span class="p">.</span><span class="n">ptr</span><span class="o">&lt;</span><span class="n">uchar</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="n">uchar</span> <span class="o">*</span><span class="n">iLabel</span> <span class="o">=</span> <span class="n">Pointlabel</span><span class="p">.</span><span class="n">ptr</span><span class="o">&lt;</span><span class="n">uchar</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">Src</span><span class="p">.</span><span class="n">cols</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">iLabel</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">iDstData</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">CheckMode</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">iLabel</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">iDstData</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">iData</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

<span class="c1">//    std::cout &lt;&lt; RemoveCount &lt;&lt; " objects removed." &lt;&lt; std::endl;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="五轮廓提取">五、轮廓提取</h2><p>不论是使用二值化还是边缘检测，最终得到的结果都是一个二值化了的图片，不论其中的点是表示物体信息还是边缘信息，我们都需要知道可能的目标的位置。因此它们最后都会被转化为轮廓，因为对这种边缘信息我们才能分析它的几何和拓扑特征。</p><p>OpenCV 中提供了轮廓提取函数：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span text-data=" C++ "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="n">cv</span><span class="o">::</span><span class="n">findContours</span><span class="p">(</span><span class="n">InputArray</span> <span class="n">image</span><span class="p">,</span> <span class="n">OutputArrayOfArrays</span> <span class="n">contours</span><span class="p">,</span> <span class="n">OutputArray</span> <span class="n">hierarchy</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">method</span><span class="p">,</span> <span class="n">Point</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">Point</span><span class="p">())</span>
</pre></table></code></div></div><p>其中：</p><ul><li><code class="language-plaintext highlighter-rouge">mode</code> ：<ul><li>RETR_EXTERNAL：只列举外轮廓<li>RETR_LIST：用列表的方式列举所有轮廓<li>RETR_TREE：用列表的方式列举所有轮廓 用树状的结构表示所有的轮廓，在这种模式下会在 <code class="language-plaintext highlighter-rouge">hierachy</code> 中记录轮廓</ul><li><code class="language-plaintext highlighter-rouge">hierachy</code>：对于每一个轮廓， <code class="language-plaintext highlighter-rouge">hierarchy</code> 都包含 4 个整型数据，分别表示：后一个轮廓的序号、前一个轮廓的序号、子轮廓的序号、父轮廓的序号。<li><code class="language-plaintext highlighter-rouge">method</code> ：<ul><li><code class="language-plaintext highlighter-rouge">CHAIN_APPROX_NONE</code> ：绝对的记录轮廓上的所有点<li><code class="language-plaintext highlighter-rouge">CHAIN_APPROX_SIMPLE</code> ：记录轮廓在上下左右四个方向上的末端点(轮廓中的关键节点)</ul></ul><p>下面演示如何使用 <code class="language-plaintext highlighter-rouge">RETR_TREE</code> 模式按照拓扑关系画出所有轮廓：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span text-data=" C++ "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="o">&amp;</span><span class="n">drawer</span><span class="p">,</span>
         <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">cv</span><span class="o">::</span><span class="n">Point</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">contours</span><span class="p">,</span>
         <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">cv</span><span class="o">::</span><span class="n">Vec4i</span> <span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">hierachy</span><span class="p">,</span>
         <span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">id</span><span class="p">,</span>
         <span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">depth</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
    <span class="k">static</span> <span class="n">cv</span><span class="o">::</span><span class="n">Scalar</span> <span class="n">COLOR_LIST</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">{</span><span class="mi">220</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">},</span> <span class="p">{</span><span class="mi">20</span><span class="p">,</span> <span class="mi">220</span><span class="p">,</span> <span class="mi">20</span><span class="p">},</span> <span class="p">{</span><span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">220</span><span class="p">}</span> <span class="p">};</span>
    <span class="n">cv</span><span class="o">::</span><span class="n">drawContours</span><span class="p">(</span><span class="n">drawer</span><span class="p">,</span> <span class="n">contours</span><span class="p">,</span> <span class="n">id</span><span class="p">,</span> <span class="n">COLOR_LIST</span><span class="p">[</span><span class="n">depth</span> <span class="o">%</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">hierachy</span><span class="p">[</span><span class="n">id</span><span class="p">][</span><span class="mi">2</span><span class="p">];</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">=</span> <span class="n">hierachy</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
        <span class="n">dfs</span><span class="p">(</span><span class="n">drawer</span><span class="p">,</span> <span class="n">contours</span><span class="p">,</span> <span class="n">hierachy</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>  <span class="c1">// 向内部的子轮廓递归</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">src</span> <span class="o">=</span> <span class="n">cv</span><span class="o">::</span><span class="n">imread</span><span class="p">(</span><span class="n">PROJECT_DIR</span><span class="s">"/assets/energy.jpg"</span><span class="p">);</span>
<span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">hsv</span><span class="p">;</span>
<span class="n">cv</span><span class="o">::</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">hsv</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">COLOR_BGR2HSV</span><span class="p">);</span>  <span class="c1">// 将颜色空间从BGR转为HSV</span>
<span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">hsv_part1</span><span class="p">,</span> <span class="n">hsv_part2</span><span class="p">;</span>
<span class="n">cv</span><span class="o">::</span><span class="n">inRange</span><span class="p">(</span><span class="n">hsv</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">Scalar</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">43</span><span class="p">,</span> <span class="mi">46</span><span class="p">),</span> <span class="n">cv</span><span class="o">::</span><span class="n">Scalar</span><span class="p">(</span><span class="mi">25</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">),</span> <span class="n">hsv_part1</span><span class="p">);</span>
<span class="n">cv</span><span class="o">::</span><span class="n">inRange</span><span class="p">(</span><span class="n">hsv</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">Scalar</span><span class="p">(</span><span class="mi">156</span><span class="p">,</span> <span class="mi">43</span><span class="p">,</span> <span class="mi">46</span><span class="p">),</span> <span class="n">cv</span><span class="o">::</span><span class="n">Scalar</span><span class="p">(</span><span class="mi">180</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">),</span> <span class="n">hsv_part2</span><span class="p">);</span> <span class="c1">// 提取红色和橙色</span>
<span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">ones_mat</span> <span class="o">=</span> <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="o">::</span><span class="n">ones</span><span class="p">(</span><span class="n">cv</span><span class="o">::</span><span class="n">Size</span><span class="p">(</span><span class="n">src</span><span class="p">.</span><span class="n">cols</span><span class="p">,</span> <span class="n">src</span><span class="p">.</span><span class="n">rows</span><span class="p">),</span> <span class="n">CV_8UC1</span><span class="p">);</span>
<span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">hsv_result</span> <span class="o">=</span> <span class="mi">255</span> <span class="o">*</span> <span class="p">(</span><span class="n">ones_mat</span> <span class="o">-</span> <span class="p">(</span><span class="n">ones_mat</span> <span class="o">-</span> <span class="n">hsv_part1</span> <span class="o">/</span> <span class="mi">255</span><span class="p">).</span><span class="n">mul</span><span class="p">(</span><span class="n">ones_mat</span> <span class="o">-</span> <span class="n">hsv_part2</span> <span class="o">/</span> <span class="mi">255</span><span class="p">));</span>  <span class="c1">// 对hsv_part1的结果和hsv_part2的结果取并集</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">cv</span><span class="o">::</span><span class="n">Point</span><span class="o">&gt;&gt;</span> <span class="n">contours</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">cv</span><span class="o">::</span><span class="n">Vec4i</span><span class="o">&gt;</span> <span class="n">hierachy</span><span class="p">;</span>
<span class="n">cv</span><span class="o">::</span><span class="n">findContours</span><span class="p">(</span><span class="n">hsv_result</span><span class="p">,</span> <span class="n">contours</span><span class="p">,</span> <span class="n">hierachy</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">RETR_TREE</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">CHAIN_APPROX_NONE</span><span class="p">);</span>
<span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">drawer</span> <span class="o">=</span> <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="o">::</span><span class="n">zeros</span><span class="p">(</span><span class="n">cv</span><span class="o">::</span><span class="n">Size</span><span class="p">(</span><span class="n">src</span><span class="p">.</span><span class="n">cols</span><span class="p">,</span> <span class="n">src</span><span class="p">.</span><span class="n">rows</span><span class="p">),</span> <span class="n">CV_8UC3</span><span class="p">);</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">=</span> <span class="n">hierachy</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="n">dfs</span><span class="p">(</span><span class="n">drawer</span><span class="p">,</span> <span class="n">contours</span><span class="p">,</span> <span class="n">hierachy</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>  <span class="c1">// 遍历所有轮廓</span>
<span class="n">cv</span><span class="o">::</span><span class="n">imshow</span><span class="p">(</span><span class="s">"src"</span><span class="p">,</span> <span class="n">src</span><span class="p">);</span>
<span class="n">cv</span><span class="o">::</span><span class="n">imshow</span><span class="p">(</span><span class="s">"contours"</span><span class="p">,</span> <span class="n">drawer</span><span class="p">);</span>
<span class="n">cv</span><span class="o">::</span><span class="n">waitKey</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</pre></table></code></div></div><p>实现效果如图：</p><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/Harry-hhj/Harry-hhj.github.io/master/_posts/2021-10-02-RM-Tutorial-3-Getting-Started-with-OpenCV.assets/energy_edge.jpg" alt="energy_edge" /></p><h2 id="六筛选">六、筛选</h2><p>仅仅使用开闭运算，对三个目标中的前两点的改善十分有限，为了进一步从大量边缘中找到目标边缘，我们在进行完轮廓提取后，还会进行形状筛选。即根据目标的形状信息，剔除形状不正确的的轮廓（这里的形状同样包括大小等各种目标独特的特征）。形状筛选的方式通常有：计算轮廓面积、计算最小外接矩形、椭圆拟合、多边形拟合等。</p><p>更准确地说，我们对提取出的轮廓使用先验信息和分类器进行筛选，从而找到我们所需要的目标。具体使用什么方法是和目标有关的。</p><p>下面列举几个常用轮廓筛选的手段：</p><h3 id="1面积周长大小约束">1）面积/周长大小约束</h3><p>面积/周长大小约束是最简单的约束之一，即通过轮廓所包含区域的大小或是轮廓的周长大小筛选指定的轮廓。</p><p>这种方法虽然简单粗暴，但对于一些环境干扰小的简单环境往往能够取得相当不错的效果。下面是一个简单的例子：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span text-data=" C++ "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="kt">bool</span> <span class="nf">judgeContourByArea</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">cv</span><span class="o">::</span><span class="n">Point</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">contour</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">cv</span><span class="o">::</span><span class="n">contourArea</span><span class="p">(</span><span class="n">contour</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2000</span><span class="p">)</span> <span class="c1">// 舍弃小轮廓</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>它对能量机关的轮廓提取如图：</p><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/Harry-hhj/Harry-hhj.github.io/master/_posts/2021-10-02-RM-Tutorial-3-Getting-Started-with-OpenCV.assets/1634192394613.png" alt="1634192394613" /></p><p>这种方法简单高效，但也尤其缺点，确定是<strong>鲁棒性低，容易受干扰</strong>，对于每一个场景往往<strong>需要针对输入调参</strong>后才能使用。</p><h3 id="2轮廓凹凸性约束">2）轮廓凹凸性约束</h3><p>这种方法能通过轮廓的凹凸性对凹轮廓或凸轮廓进行有针对性的筛选。一般来说可以通过将<code class="language-plaintext highlighter-rouge">轮廓的凸包</code>与<code class="language-plaintext highlighter-rouge">轮廓本身</code>进行比较来实现。</p><p>常用的比较方法有：</p><ul><li>面积比例比较<ul><li>对于凸轮廓，轮廓的凸包面积与轮廓本身的面积比应该接近 $1:1$ ，而一般的凹轮廓的比值应该明显大于 $1$ 。</ul><li>周长比值比较<ul><li>一般来说，对于凸轮廓，轮廓的凸包周长和轮廓本身的周长相近，而凹轮廓的轮廓本身周长应当明显大于凸包周长。</ul></ul><p>下面是一个简单的例子，筛选轮廓中的凹轮廓：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span text-data=" C++ "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="kt">bool</span> <span class="nf">judgeContourByConvexity</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">cv</span><span class="o">::</span><span class="n">Point</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">contour</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">contourArea</span><span class="p">(</span><span class="n">contour</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">500</span><span class="p">)</span>  <span class="c1">// 去除过小轮廓的干扰</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">hull_area</span><span class="p">,</span> <span class="n">contour_area</span><span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">cv</span><span class="o">::</span><span class="n">Point</span><span class="o">&gt;</span> <span class="n">hull</span><span class="p">;</span>
    <span class="n">cv</span><span class="o">::</span><span class="n">convexHull</span><span class="p">(</span><span class="n">contour</span><span class="p">,</span> <span class="n">hull</span><span class="p">);</span>

    <span class="n">hull_area</span> <span class="o">=</span> <span class="n">cv</span><span class="o">::</span><span class="n">contourArea</span><span class="p">(</span><span class="n">hull</span><span class="p">);</span>
    <span class="n">contour_area</span> <span class="o">=</span> <span class="n">cv</span><span class="o">::</span><span class="n">contourArea</span><span class="p">(</span><span class="n">contour</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">hull_area</span> <span class="o">&gt;</span> <span class="mf">1.5</span> <span class="o">*</span> <span class="n">contour_area</span><span class="p">)</span>  <span class="c1">// 判断凹凸性</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>它对能量机关的提取如图：</p><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/Harry-hhj/Harry-hhj.github.io/master/_posts/2021-10-02-RM-Tutorial-3-Getting-Started-with-OpenCV.assets/1634193485720.png" alt="1634193485720" /></p><h3 id="3与矩形相似性约束">3）与矩形相似性约束</h3><p>在轮廓筛选时常常会需要筛选一些较规则的形状，如矩形轮廓等。在这种情况下，一般来说我们可以通过将<code class="language-plaintext highlighter-rouge">轮廓的最小外接矩形</code>与<code class="language-plaintext highlighter-rouge">轮廓本身</code>进行比较来实现筛选。</p><p>常见的筛选方法与凹凸性约束相似，<strong>也是通过面积和周长比较来实现</strong>。此外，由于矩形的特殊性，也可以通过<strong>矩形的长宽比</strong>进行筛选。</p><p>下面是一个简单的例子，筛选能量机关的装甲板轮廓：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span text-data=" C++ "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="kt">bool</span> <span class="nf">judgeContourByRect</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">cv</span><span class="o">::</span><span class="n">Point</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">contour</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">cv</span><span class="o">::</span><span class="n">contourArea</span><span class="p">(</span><span class="n">contour</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">500</span><span class="p">)</span>     <span class="c1">// 排除小轮廓的干扰</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">rect_area</span><span class="p">,</span> <span class="n">contour_area</span><span class="p">,</span> <span class="n">rect_length</span><span class="p">,</span> <span class="n">contour_length</span><span class="p">;</span>

    <span class="n">cv</span><span class="o">::</span><span class="n">RotatedRect</span> <span class="n">rect</span> <span class="o">=</span> <span class="n">cv</span><span class="o">::</span><span class="n">minAreaRect</span><span class="p">(</span><span class="n">contour</span><span class="p">);</span>
    <span class="n">rect_area</span> <span class="o">=</span> <span class="n">rect</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">area</span><span class="p">();</span>
    <span class="n">contour_area</span> <span class="o">=</span> <span class="n">cv</span><span class="o">::</span><span class="n">contourArea</span><span class="p">(</span><span class="n">contour</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">rect_area</span> <span class="o">&gt;</span> <span class="mf">1.3</span> <span class="o">*</span> <span class="n">contour_area</span><span class="p">)</span>    <span class="c1">// 轮廓面积约束</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">rect_length</span> <span class="o">=</span> <span class="p">(</span><span class="n">rect</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">height</span> <span class="o">+</span> <span class="n">rect</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">contour_length</span> <span class="o">=</span> <span class="n">cv</span><span class="o">::</span><span class="n">arcLength</span><span class="p">(</span><span class="n">contour</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">fabs</span><span class="p">(</span><span class="n">rect_length</span> <span class="o">-</span> <span class="n">contour_length</span><span class="p">)</span> <span class="o">/</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">rect_length</span><span class="p">,</span> <span class="n">contour_length</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.1</span><span class="p">)</span>         <span class="c1">// 轮廓周长约束</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">rect</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="n">rect</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">height</span><span class="p">)</span> <span class="o">/</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">rect</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="n">rect</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">height</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1.9</span><span class="p">)</span>       <span class="c1">// 长宽比约束</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>运行结果如图：</p><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/Harry-hhj/Harry-hhj.github.io/master/_posts/2021-10-02-RM-Tutorial-3-Getting-Started-with-OpenCV.assets/1634195583622.png" alt="1634195583622" /></p><p><br /></p><p>以上几种方法是主要的几种基于<code class="language-plaintext highlighter-rouge">单个轮廓本身几何性质</code>的筛选方法，下面介绍几种轮廓间几何关系的约束。</p><h3 id="4拓扑关系约束">4）拓扑关系约束</h3><p>在一张复杂的图片中，轮廓中往往有各种复杂的拓扑关系。</p><p>例如一个轮廓，它的拓扑关系可能有以下几种主要性质：</p><ul><li>是否是最外层轮廓<li>是否是最内层轮廓<li>是否有子轮廓<ul><li>子轮廓的个数是多少</ul><li>它是谁的子轮廓<li>……</ul><p>例如当我们想筛选未被激活的装甲板，我们会发现他有两个拓扑关系：</p><ol><li>它是最外层轮廓<li>它有一个子轮廓</ol><p>再或者我们想筛选已经被激活的装甲板，我们会发现他也有连个拓扑关系：</p><ol><li>它是最外层子轮廓<li>它有三个子轮廓</ol><p>下面是一个简单的例子，筛选已经被激活的装甲板：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span text-data=" C++ "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="kt">bool</span> <span class="nf">judgeContourByTuopu</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">cv</span><span class="o">::</span><span class="n">Vec4i</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">hierachy</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">id</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">dep</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">dep</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>       <span class="c1">// 判断是否是最外层轮廓</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    
    <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">hierachy</span><span class="p">[</span><span class="n">id</span><span class="p">][</span><span class="mi">2</span><span class="p">];</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">=</span> <span class="n">hierachy</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>   <span class="c1">// 子轮廓计数</span>
        <span class="n">cnt</span><span class="o">++</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">)</span>     <span class="c1">// 判断子轮廓个数是否为3</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>运行结果如图：</p><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/Harry-hhj/Harry-hhj.github.io/master/_posts/2021-10-02-RM-Tutorial-3-Getting-Started-with-OpenCV.assets/1634197853445.png" alt="1634197853445" /></p><h3 id="5通过与其他轮廓的几何关系判断">5）通过与其他轮廓的几何关系判断</h3><p>这种方法整体上灵活多变，要根据具体情况选择具体方法，整体的思想是通过与另一个已知轮廓（也可能未知）的几何关系进行筛选。</p><p>这里以筛选已激活装甲板中的空白区域为例：观察发现，已激活装甲板中的空白区域为一个接近矩形的四边形，其中的长边与扇叶的最小外接矩形的长边有着<strong>接近垂直</strong>的几何关系。而在上一问中，我们已经筛选出了已激活装甲板，因此这里我们可以利用这一性质完成空白区域的筛选。</p><p>下面是一个简单的例子：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span text-data=" C++ "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
</pre><td class="rouge-code"><pre><span class="kt">bool</span> <span class="nf">judgeContourByRelation</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">cv</span><span class="o">::</span><span class="n">Point</span><span class="o">&gt;&gt;</span> <span class="o">&amp;</span><span class="n">contours</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">cv</span><span class="o">::</span><span class="n">Vec4i</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">hierachy</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">id</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">dep</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">hierachy</span><span class="p">[</span><span class="n">id</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>     <span class="c1">// 去除最外层轮廓</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">dep</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>                   <span class="c1">// 判断是否是第二层轮廓</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">judgeContourByTuopu</span><span class="p">(</span><span class="n">hierachy</span><span class="p">,</span> <span class="n">hierachy</span><span class="p">[</span><span class="n">id</span><span class="p">][</span><span class="mi">3</span><span class="p">],</span> <span class="n">dep</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>   <span class="c1">// 判断外轮廓是否为已激活扇叶</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">cv</span><span class="o">::</span><span class="n">RotatedRect</span> <span class="n">rect_father</span> <span class="o">=</span> <span class="n">cv</span><span class="o">::</span><span class="n">minAreaRect</span><span class="p">(</span><span class="n">contours</span><span class="p">[</span><span class="n">hierachy</span><span class="p">[</span><span class="n">id</span><span class="p">][</span><span class="mi">3</span><span class="p">]]);</span>
    <span class="n">cv</span><span class="o">::</span><span class="n">RotatedRect</span> <span class="n">rect_this</span> <span class="o">=</span> <span class="n">cv</span><span class="o">::</span><span class="n">minAreaRect</span><span class="p">(</span><span class="n">contours</span><span class="p">[</span><span class="n">id</span><span class="p">]);</span>
    <span class="n">cv</span><span class="o">::</span><span class="n">Point2f</span> <span class="n">direction_father</span><span class="p">;</span>
    <span class="n">cv</span><span class="o">::</span><span class="n">Point2f</span> <span class="n">direction_this</span><span class="p">;</span>

<span class="c1">// 寻找父轮廓最小外接矩形的短边</span>
    <span class="n">cv</span><span class="o">::</span><span class="n">Point2f</span> <span class="n">pts</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
    <span class="n">rect_father</span><span class="p">.</span><span class="n">points</span><span class="p">(</span><span class="n">pts</span><span class="p">);</span>
    <span class="kt">double</span> <span class="n">length1</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="p">((</span><span class="n">pts</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">x</span> <span class="o">-</span> <span class="n">pts</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">pts</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">x</span> <span class="o">-</span> <span class="n">pts</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">pts</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">y</span> <span class="o">-</span> <span class="n">pts</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">pts</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">y</span> <span class="o">-</span> <span class="n">pts</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">y</span><span class="p">));</span>
    <span class="kt">double</span> <span class="n">length2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="p">((</span><span class="n">pts</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">x</span> <span class="o">-</span> <span class="n">pts</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">pts</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">x</span> <span class="o">-</span> <span class="n">pts</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">pts</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">y</span> <span class="o">-</span> <span class="n">pts</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">pts</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">y</span> <span class="o">-</span> <span class="n">pts</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">y</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">length1</span> <span class="o">&lt;</span> <span class="n">length2</span><span class="p">)</span>
        <span class="n">direction_father</span> <span class="o">=</span> <span class="p">{</span><span class="n">pts</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">x</span> <span class="o">-</span> <span class="n">pts</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">x</span><span class="p">,</span> <span class="n">pts</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">y</span> <span class="o">-</span> <span class="n">pts</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">y</span><span class="p">};</span>
    <span class="k">else</span>
        <span class="n">direction_father</span> <span class="o">=</span> <span class="p">{</span><span class="n">pts</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">x</span> <span class="o">-</span> <span class="n">pts</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">x</span><span class="p">,</span> <span class="n">pts</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">y</span> <span class="o">-</span> <span class="n">pts</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">y</span><span class="p">};</span>
   
<span class="c1">// 寻找当前轮廓最小外接矩形的长边 </span>
    <span class="n">rect_this</span><span class="p">.</span><span class="n">points</span><span class="p">(</span><span class="n">pts</span><span class="p">);</span>
    <span class="n">length1</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="p">((</span><span class="n">pts</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">x</span> <span class="o">-</span> <span class="n">pts</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">pts</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">x</span> <span class="o">-</span> <span class="n">pts</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">pts</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">y</span> <span class="o">-</span> <span class="n">pts</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">pts</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">y</span> <span class="o">-</span> <span class="n">pts</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">y</span><span class="p">));</span>
    <span class="n">length2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="p">((</span><span class="n">pts</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">x</span> <span class="o">-</span> <span class="n">pts</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">pts</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">x</span> <span class="o">-</span> <span class="n">pts</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">pts</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">y</span> <span class="o">-</span> <span class="n">pts</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">pts</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">y</span> <span class="o">-</span> <span class="n">pts</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">y</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">length1</span> <span class="o">&gt;</span> <span class="n">length2</span><span class="p">)</span>
        <span class="n">direction_this</span> <span class="o">=</span> <span class="p">{</span><span class="n">pts</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">x</span> <span class="o">-</span> <span class="n">pts</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">x</span><span class="p">,</span> <span class="n">pts</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">y</span> <span class="o">-</span> <span class="n">pts</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">y</span><span class="p">};</span>
    <span class="k">else</span>
        <span class="n">direction_this</span> <span class="o">=</span> <span class="p">{</span><span class="n">pts</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">x</span> <span class="o">-</span> <span class="n">pts</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">x</span><span class="p">,</span> <span class="n">pts</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">y</span> <span class="o">-</span> <span class="n">pts</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">y</span><span class="p">};</span>

<span class="c1">// 计算[父轮廓最小外接矩形的短边]与[当前轮廓最小外接矩形的长边]夹角的余弦值</span>
    <span class="kt">double</span> <span class="n">cosa</span> <span class="o">=</span> <span class="p">(</span><span class="n">direction_this</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">direction_father</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">direction_this</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">direction_father</span><span class="p">.</span><span class="n">y</span><span class="p">)</span> <span class="o">/</span> 
                <span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="p">(</span><span class="n">direction_this</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">direction_this</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">direction_this</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">direction_this</span><span class="p">.</span><span class="n">y</span><span class="p">)</span> <span class="o">/</span>
                <span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="p">(</span><span class="n">direction_father</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">direction_father</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">direction_father</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">direction_father</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">cosa</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">fabs</span><span class="p">(</span><span class="n">cosa</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.1</span><span class="p">)</span>    <span class="c1">// 筛选不符合条件的轮廓</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>运行结果如图：</p><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/Harry-hhj/Harry-hhj.github.io/master/_posts/2021-10-02-RM-Tutorial-3-Getting-Started-with-OpenCV.assets/1634199484314.png" alt="1634199484314" /></p><p>对于轮廓筛选的部分就介绍到这里，传统视觉的奥妙远不止于此。以上内容有一部分是笔者的个人总结，并不一定是主流方法。读者可以在实践中慢慢探索，寻找自己的传统视觉的思路。</p><h2 id="六传统视觉原则">六、传统视觉原则</h2><p><strong>传统方法一般不怕多，就怕少。多出来的加上分类器总有办法筛选掉，但少的就没办法补上了。</strong>因此，及时你想得到一个完美的结果，也不应该将阈值设置到一个非常严苛的程度，不然算法的鲁棒性将收到影响。</p><h2 id="七总结">七、总结</h2><p>对于传统图像处理，我们有两种方式，一种基于二值化，一种基于边缘检测。不论哪种方法，我们之后需要对图像进行滤波或形态学处理，在更佳的图像上进行轮廓提取，最后根据轮廓的几何性质等设置分类器提取出我们想要的目标。</p><h2 id="八作业">八、作业</h2><p>链接: <em><a href="https://pan.baidu.com/s/1S94gVEPPdB1m4mwlFA7ImA">https://pan.baidu.com/s/1S94gVEPPdB1m4mwlFA7ImA</a></em> 提取码: 49w9</p><ol><li><p>苹果识别，请识别下图中的苹果</p><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/Harry-hhj/Harry-hhj.github.io/master/_posts/2021-10-02-RM-Tutorial-3-Getting-Started-with-OpenCV.assets/auto-orient&amp;e=1634303762&amp;token=FufIJBFRUFc5GcrmOa3fwZnzhFDNlMKS3k41hGRG:MgrzBWzw8VZt3xgwZX_T5b1NH-g.png" alt="apple.png" /></p><li><p>识别链接中两个视频中的能量机关，框出亮起扇叶的顶部矩形块位置</p></ol><p><br /></p><p><strong>如果觉得本教程不错或对您有用，请前往项目地址 <a href="https://github.com/Harry-hhj/Harry-hhj.github.io">https://github.com/Harry-hhj/Harry-hhj.github.io</a> 点击 Star :) ，这将是对我的肯定和鼓励，谢谢！</strong></p><p><br /></p><h2 id="九参考文献">九、参考文献</h2><ol><li><a href="https://www.jianshu.com/p/cfc0c1f87bf8">opencv中mat详细解析</a><li><a href="https://blog.csdn.net/qq_41741344/article/details/104341760">【Opencv】Opencv中的Mat类介绍</a><li><a href="https://www.cnblogs.com/wangyblzu/p/5710715.html">OpenCV中HSV颜色模型及颜色分量范围</a><li><a href="https://zhuanlan.zhihu.com/p/110787009">图像处理中常见的形态学方法</a><li><a href="https://blog.csdn.net/kksc1099054857/article/details/76569718">opencv getStructuringElement函数</a><li><a href="https://blog.csdn.net/zqx951102/article/details/83004037">opencv中的开运算，闭运算，形态学梯度，顶帽和黑帽简介</a><li><a href="https://blog.csdn.net/keen_zuxwang/article/details/72768092">opencv 形态学变换 morphologyEx函数</a><li><a href="https://blog.csdn.net/l740450789/article/details/47295131">Opencv–形态学图像处理–膨胀与腐蚀，开操作与闭操作</a></ol><hr /><p>作者列表：</p><ul><li>xinyang，Github主页：<a href="https://github.com/xinyang-go">传送门</a><li><p>E-T-E-R-N-A-L-B-L-U-E，<a href="https://github.com/E-T-E-R-N-A-L-B-L-U-E">传送门</a></p><li>Harry-hhj，Github主页：<a href="https://github.com/Harry-hhj">传送门</a></ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/course/'>Course</a>, <a href='/categories/rm/'>RM</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/getting-started/" class="post-tag no-text-decoration" >getting started</a> <a href="/tags/robomaster/" class="post-tag no-text-decoration" >robomaster</a> <a href="/tags/opencv/" class="post-tag no-text-decoration" >opencv</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=RM 教程 3 —— OpenCV 传统视觉 - Harry's Blog&url=https://harry-hhj.github.io/posts/RM-Tutorial-3-Getting-Started-with-OpenCV/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=RM 教程 3 —— OpenCV 传统视觉 - Harry's Blog&u=https://harry-hhj.github.io/posts/RM-Tutorial-3-Getting-Started-with-OpenCV/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=RM 教程 3 —— OpenCV 传统视觉 - Harry's Blog&url=https://harry-hhj.github.io/posts/RM-Tutorial-3-Getting-Started-with-OpenCV/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/RM-Tutorial-5-Monocular-Vision/">RM 教程 5 —— 单目视觉</a><li><a href="/posts/RM-Tutorial-Catalogue/">RoboMaster 课程目录</a><li><a href="/posts/NN-Tutorial-Catalogue/">神经网络课程目录</a><li><a href="/posts/RM-Tutorial-3-Getting-Started-with-OpenCV/">RM 教程 3 —— OpenCV 传统视觉</a><li><a href="/posts/RM-Tutorial-4-Camera/">RM 教程 4 —— 相机</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/getting-started/">getting started</a> <a class="post-tag" href="/tags/install/">install</a> <a class="post-tag" href="/tags/robomaster/">robomaster</a> <a class="post-tag" href="/tags/computer-science/">computer science</a> <a class="post-tag" href="/tags/tools/">tools</a> <a class="post-tag" href="/tags/catalog/">catalog</a> <a class="post-tag" href="/tags/opencv/">opencv</a> <a class="post-tag" href="/tags/pytorch/">pytorch</a> <a class="post-tag" href="/tags/c-c/">c/c++</a> <a class="post-tag" href="/tags/camera/">camera</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/RM-Tutorial-2-Install-OpenCV/"><div class="card-body"> <span class="timeago small" >Oct 2<i class="unloaded">2021-10-02T13:30:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>RM 教程 2 —— 安装 OpenCV</h3><div class="text-muted small"><p> RM 教程 2 —— 安装 OpenCV 机械是血肉，电控是大脑，视觉是灵魂。 一、简介 OpenCV 是计算机视觉中经典的专用库，其支持多语言，跨平台，功能强大。 opencv-python 为OpenCV 提供了 Python 接口，使得使用者在 Python 中能够调用 C/C++ ，在保证易读性和运行效率的前提下，实现所需的功能。 OpenCV 现在支持与计算机视...</p></div></div></a></div><div class="card"> <a href="/posts/RM-Tutorial-1-Linux-Introduction/"><div class="card-body"> <span class="timeago small" >Sep 24<i class="unloaded">2021-09-24T16:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>RM 教程 1 —— Linux 教程</h3><div class="text-muted small"><p> RM 教程 1 —— Linux 教程 机械是血肉，电控是大脑，视觉是灵魂。 一、Why Linux &amp; Why Ubuntu Ubuntu 是一个十分流行并且好用的 Linux 桌面发行版本。截止到目前，Ubuntu 已经发行了 Ubuntu 20.04 的版本，并且其稳定性和支持已经很不错了。你可以在这里下载各个版本的 Ubuntu 系统镜像文件，虚拟机的话一般...</p></div></div></a></div><div class="card"> <a href="/posts/RM-Tutorial-4-Camera/"><div class="card-body"> <span class="timeago small" >Oct 10<i class="unloaded">2021-10-10T10:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>RM 教程 4 —— 相机</h3><div class="text-muted small"><p> RM 教程 4 —— 相机 机械是肉体， 电控是大脑， 视觉是灵魂 一、相机结构简介 广义的相机由两部分组成： 工业相机 镜头 （1）工业相机 了解工业相机的相关参数能够帮助我们更好的理解相机功能，进而帮助我们完成对相机的选型工作。所谓外行看热闹，内行看门道，工业相机的门道就从其参数开始。 1. 分辨率 相机的传感器 sensor 是有许多像素点按照矩阵的...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/RM-Tutorial-2-Install-OpenCV/" class="btn btn-outline-primary" prompt="Older"><p>RM 教程 2 —— 安装 OpenCV</p></a> <a href="/posts/RM-Tutorial-4-Camera/" class="btn btn-outline-primary" prompt="Newer"><p>RM 教程 4 —— 相机</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2021 <a href="https://github.com/Harry-hhj">HHJ</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/getting-started/">getting started</a> <a class="post-tag" href="/tags/install/">install</a> <a class="post-tag" href="/tags/robomaster/">robomaster</a> <a class="post-tag" href="/tags/computer-science/">computer science</a> <a class="post-tag" href="/tags/tools/">tools</a> <a class="post-tag" href="/tags/catalog/">catalog</a> <a class="post-tag" href="/tags/opencv/">opencv</a> <a class="post-tag" href="/tags/pytorch/">pytorch</a> <a class="post-tag" href="/tags/c-c/">c/c++</a> <a class="post-tag" href="/tags/camera/">camera</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script> /* see: <https://docs.mathjax.org/en/latest/options/input/tex.html#tex-options> */ MathJax = { tex: { inlineMath: [ /* start/end delimiter pairs for in-line math */ ['$','$'], ['\\(','\\)'] ], displayMath: [ /* start/end delimiter pairs for display math */ ['$$', '$$'], ['\\[', '\\]'] ] } }; </script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"> </script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script>

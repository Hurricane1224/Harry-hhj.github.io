<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://harry-hhj.github.io/</id><title>Harry's Blog</title><subtitle>I hope it will become a grain of gold someday.</subtitle> <updated>2021-11-12T14:32:47+08:00</updated> <author> <name>HHJ</name> <uri>https://harry-hhj.github.io/</uri> </author><link rel="self" type="application/atom+xml" href="https://harry-hhj.github.io/feed.xml"/><link rel="alternate" type="text/html" hreflang="zh" href="https://harry-hhj.github.io/"/> <generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator> <rights> © 2021 HHJ </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>Config ccache</title><link href="https://harry-hhj.github.io/posts/Config-ccache/" rel="alternate" type="text/html" title="Config ccache" /><published>2021-11-03T21:15:00+08:00</published> <updated>2021-11-03T21:15:00+08:00</updated> <id>https://harry-hhj.github.io/posts/Config-ccache/</id> <content src="https://harry-hhj.github.io/posts/Config-ccache/" /> <author> <name>Harry-hhj</name> </author> <category term="Tutorial" /> <category term="ccache" /> <summary> Ccache 这篇博客介绍一个小工具 ccache ，可以提高再次编译的速度。其原理是通过吧项目的源文件用 ccache 编译器编译，然后缓存编译生成的信息，从而在下一次编译时，利用这个缓存加快编译的速度，目前支持的语言有 C 、 C++ 、 Objective-C 、 Objective-C++ ，如果找不到 ccache 编译器，还是会选择系统默认的编译器来编译源文件。 接下来讲述 ccache 的利用过程。 一、安装 这里介绍 Ubuntu 的安装方法。 首先通过 apt 安装： sudo apt install ccache 安装完后我们不能直接使用，需要先进行配置: sudo gedit ~/.bashrc 在新打开的文档末尾回车，添加如下语句，注意 &amp;lt;username&amp;gt; 要改成你的用户名。 export CCACHE_DIR="/hom... </summary> </entry> <entry><title>Unreal Engine 4 课程目录</title><link href="https://harry-hhj.github.io/posts/Unreal-Engine-Tutorial-Catalogue/" rel="alternate" type="text/html" title="Unreal Engine 4 课程目录" /><published>2021-10-21T23:59:00+08:00</published> <updated>2021-10-21T23:59:00+08:00</updated> <id>https://harry-hhj.github.io/posts/Unreal-Engine-Tutorial-Catalogue/</id> <content src="https://harry-hhj.github.io/posts/Unreal-Engine-Tutorial-Catalogue/" /> <author> <name>Harry-hhj</name> </author> <category term="Course" /> <category term="Unreal Engine" /> <summary> Unreal Engine Catalogue 一、课程简介 本课程以动手实践为主，在实践中理解相关原理，以能够实战进行项目为首要目标，不要求知识的系统性学习。 Unreal介绍。。。 二、课程教程 如果觉得本教程不错或对您有用，请前往项目地址 https://github.com/Harry-hhj/Harry-hhj.github.io 点击 Star :) ，这将是对我的肯定和鼓励，谢谢！ 作者：Harry-hhj，github主页：传送门 </summary> </entry> <entry><title>RM 教程 5 —— 单目视觉</title><link href="https://harry-hhj.github.io/posts/RM-Tutorial-5-Monocular-Vision/" rel="alternate" type="text/html" title="RM 教程 5 —— 单目视觉" /><published>2021-10-15T21:30:00+08:00</published> <updated>2021-11-04T19:01:43+08:00</updated> <id>https://harry-hhj.github.io/posts/RM-Tutorial-5-Monocular-Vision/</id> <content src="https://harry-hhj.github.io/posts/RM-Tutorial-5-Monocular-Vision/" /> <author> <name>Harry-hhj</name> </author> <category term="Course" /> <category term="RM" /> <summary> RM 教程 5 —— 单目视觉 机械是肉体， 电控是大脑， 视觉是灵魂 一、仿射变换与透视变换 0. 再谈其次坐标系 在上一讲中，我们提到了齐次坐标系。对于二维平面上的点 $(x, y)$ ， 我们常常将它写成为 $(x, y, 1)^T$ ，这是一个典型的齐次坐标。同样的，在三维空间中，我们有坐标 $(x, y, z, 1)^T$ ，这也是一个齐次坐标形式。 显然，对于齐次坐标和非齐次坐标，我们可以简单地通过删除最后一个坐标 $1$ 来实现他们之间的转换。但这样看来，齐次坐标的表述仍然非常奇怪，因为它多了一个莫名其妙的限制，就是最后一个坐标数值一定为 $1$ 。那么一个坐标三元组 $(x, y, 2)^T$ 是否也有自己的意义呢? 对此，我们规定对于任何非零值 $k$ ， $(kx, ky, k)^T$ 表示二维坐标中的同一个点，也就是说，当两个三元组相差一个公... </summary> </entry> <entry><title>神经网络集训 —— Numpy 的使用</title><link href="https://harry-hhj.github.io/posts/Numpy-Tutorial/" rel="alternate" type="text/html" title="神经网络集训 —— Numpy 的使用" /><published>2021-10-14T22:00:00+08:00</published> <updated>2021-10-20T00:32:13+08:00</updated> <id>https://harry-hhj.github.io/posts/Numpy-Tutorial/</id> <content src="https://harry-hhj.github.io/posts/Numpy-Tutorial/" /> <author> <name>Harry-hhj</name> </author> <category term="Course" /> <category term="Nerual Network" /> <summary> 神经网络集训 —— Numpy 的使用 在讲解具体的知识点之前，先来做做以下的问卷，进行一个基础的自查。这样，既能避免过分地自信导致学习态度的降低，也能有针对性地学习自己不理解的知识。当然，做题时请不要借助外部资料！ 链接: https://pan.baidu.com/s/1Ip4Dz6sAel3htlETxWbOYg 提取码: op3f 一、Python 基础 （1）import 机制 对于 Python 脚本， import 的顺序不同，运行脚本不同，程序执行的代码可能不同，结果自然也不会相同。 我们来看以下三个脚本： A.py ： # A.py x=1 def func(val): print(val) return x + val x = func(4) B.py ： # B.py def func(val): print(val... </summary> </entry> <entry><title>神经网络课程目录</title><link href="https://harry-hhj.github.io/posts/NN-Tutorial-Catalogue/" rel="alternate" type="text/html" title="神经网络课程目录" /><published>2021-10-13T00:00:00+08:00</published> <updated>2021-11-04T18:58:17+08:00</updated> <id>https://harry-hhj.github.io/posts/NN-Tutorial-Catalogue/</id> <content src="https://harry-hhj.github.io/posts/NN-Tutorial-Catalogue/" /> <author> <name>Harry-hhj</name> </author> <category term="Course" /> <category term="Nerual Network" /> <summary> NN Tutorial Catalogue 机械是血肉，电控是大脑，视觉是灵魂。 一、培训安排 二、培训教程 神经网络集训 —— Numpy 的使用 如果觉得本教程不错或对您有用，请前往项目地址 https://github.com/Harry-hhj/Harry-hhj.github.io 点击 Star :) ，这将是对我的肯定和鼓励，谢谢！ 作者：Harry-hhj，github主页：传送门 </summary> </entry> </feed>
